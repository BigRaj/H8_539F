#@define H8_VERSION "1"

#@include "h8500_tokens.sinc"
#@include "h8500_mov.sinc"

define endian = big;
define alignment = 1;

define space RAM type=ram_space size=4 default;
define space REGISTER type=register_space size=4;

define register offset=0 size=2
{
    R0:2, R1:2, R2:2, R3:2, R4:2, R5:2, R6:2, R7:2,
    SP:2, PC:2, CCR:1
}

define token instr16 (16)
{
    op = (15,8)
    mode = (7,0)
}

define token instr8 (8)
{
    op = (7,0)
}

define constructor MOV_RR
"mov r{src}, r{dst}" is instr16 & op=0x60
{
    dst = (mode & 0xF0) >> 4;
    src = (mode & 0x0F);
    R[dst] = R[src];
}

define constructor ADD_RR
"add r{src}, r{dst}" is instr16 & op=0x30
{
    dst = (mode & 0xF0) >> 4;
    src = (mode & 0x0F);
    R[dst] = R[dst] + R[src];
}

define constructor SUB_RR
"sub r{src}, r{dst}" is instr16 & op=0x38
{
    dst = (mode & 0xF0) >> 4;
    src = (mode & 0x0F);
    R[dst] = R[dst] - R[src];
}

define constructor INC_R
"inc r{dst}" is instr8 & op=0x1A
{
    dst = mode;
    R[dst] = R[dst] + 1;
}

define constructor DEC_R
"dec r{dst}" is instr8 & op=0x1B
{
    dst = mode;
    R[dst] = R[dst] - 1;
}

define constructor JMP_ABS
"jmp {addr}" is instr16 & op=0x5A
{
    addr = RAM:2;
    goto addr;
}

define constructor BRA_REL
"bra {offset}" is instr8 & op=0x20
{
    offset = mode;
    goto inst_next + offset;
}

define constructor BEQ_REL
"beq {offset}" is instr8 & op=0x21
{
    offset = mode;
    if (Z == 1) goto inst_next + offset;
}

define constructor BNE_REL
"bne {offset}" is instr8 & op=0x22
{
    offset = mode;
    if (Z == 0) goto inst_next + offset;
}

define constructor RTS
"rts" is instr8 & op=0x39
{
    goto [SP];
    SP = SP + 2;
}

define constructor RTE
"rte" is instr8 & op=0x3B
{
    CCR = [SP];
    SP = SP + 1;
    PC = [SP];
    SP = SP + 2;
    goto PC;
}

define constructor BSET
"bset #bit, @addr" is instr16 & op=0x90
{
    bit = (mode & 0xF0) >> 4;
    addr = RAM:1;
    RAM[addr] = RAM[addr] | (1 << bit);
}

define constructor BCLR
"bclr #bit, @addr" is instr16 & op=0x91
{
    bit = (mode & 0xF0) >> 4;
    addr = RAM:1;
    RAM[addr] = RAM[addr] & ~(1 << bit);
}

define constructor BTST
"btst #bit, @addr" is instr16 & op=0x92
{
    bit = (mode & 0xF0) >> 4;
    addr = RAM:1;
    Z = (RAM[addr] & (1 << bit)) == 0;
}

define constructor SHL_R
"shl r{dst}" is instr8 & op=0x48
{
    dst = mode;
    R[dst] = R[dst] << 1;
}

define constructor SHR_R
"shr r{dst}" is instr8 & op=0x49
{
    dst = mode;
    R[dst] = R[dst] >> 1;
}

define constructor ROL_R
"rol r{dst}" is instr8 & op=0x4A
{
    dst = mode;
    tmp = R[dst];
    carry = (tmp & 0x8000) >> 15;
    R[dst] = (tmp << 1) | carry;
}

define constructor ROR_R
"ror r{dst}" is instr8 & op=0x4B
{
    dst = mode;
    tmp = R[dst];
    carry = tmp & 0x1;
    R[dst] = (tmp >> 1) | (carry << 15);
}

define constructor MOV_B_MEM
"mov.b r{src}, @addr" is instr16 & op=0x70
{
    src = (mode & 0xF0) >> 4;
    addr = RAM:1;
    RAM[addr] = R[src] & 0xFF;
}

define constructor MOV_B_REG
"mov.b @addr, r{dst}" is instr16 & op=0x71
{
    dst = (mode & 0xF0) >> 4;
    addr = RAM:1;
    R[dst] = RAM[addr] & 0xFF;
}

define constructor PUSH_R
"push r{src}" is instr8 & op=0x2A
{
    src = mode;
    SP = SP - 2;
    RAM[SP] = R[src];
}

define constructor POP_R
"pop r{dst}" is instr8 & op=0x2B
{
    dst = mode;
    R[dst] = RAM[SP];
    SP = SP + 2;
}

define constructor NOP
"nop" is instr8 & op=0x00
{
    # No operation
}

define constructor TRAPA
"trapa #vec" is instr8 & op=0x3F
{
    vec = mode;
    # Trap to interrupt vector
    goto RAM[vec * 2];
}

define constructor MOV_IMM_R
"mov #imm, r{dst}" is instr16 & op=0xE0
{
    dst = (mode & 0xF0) >> 4;
    imm = mode & 0x0F;
    R[dst] = imm;
}

define constructor ADD_IMM_R
"add #imm, r{dst}" is instr16 & op=0xE8
{
    dst = (mode & 0xF0) >> 4;
    imm = mode & 0x0F;
    R[dst] = R[dst] + imm;
}

define constructor CMP_IMM_R
"cmp #imm, r{dst}" is instr16 & op=0xE1
{
    dst = (mode & 0xF0) >> 4;
    imm = mode & 0x0F;
    Z = (R[dst] == imm);
}

define constructor MOV_R_IO
"mov r{src}, @io_addr" is instr16 & op=0xA0
{
    src = (mode & 0xF0) >> 4;
    io_addr = RAM:1;
    RAM[io_addr] = R[src];
}

define constructor MOV_IO_R
"mov @io_addr, r{dst}" is instr16 & op=0xA1
{
    dst = (mode & 0xF0) >> 4;
    io_addr = RAM:1;
    R[dst] = RAM[io_addr];
}

define constructor UNKNOWN
"db {byte}" is instr8
{
    byte = op;
    # Unknown instruction â€” treat as data
}
