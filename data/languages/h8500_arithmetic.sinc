# ADD:G.B <EAs>, Rd row

# ADD:G.B Rn, Rd
:ADDG.B ea_reg,op_reg is ea=0b1010 & op_code=0b00100 & Sz=0 & ea_reg & op_reg
{
	op_reg = op_reg + ea_reg;
}

# ADD:G.B @Rn, Rd
:ADDG.B @ea_reg,op_reg is ea=0b1101 & op_code=0b00100 & Sz=0 & ea_reg & op_reg
{
	op_reg = op_reg + ea_reg;
}

# ADD:G.B @(d:8,Rn), Rd
:ADDG.B @(disp8,ea_reg),op_reg is ea=0b1110 & op_code=0b00100 & Sz=0 & ea_reg & disp8 & op_reg
{
	local addr:3 = zext(ea_reg) + sext(disp8:1);
    local val:1 = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 + val));
}

# ADD:G.B @(d:16,Rn), Rd
:ADDG.B @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b00100 & Sz_32=0 & ea_reg_32 & disp16_32 & op_reg_32
{
	local addr:3 = zext(ea_reg_32) + sext(disp16_32:2);
	local val:1 = *[ram]:1 addr;
	op_reg_32 = (op_reg_32 & 0xFF00) | zext((op_reg_32:1 + val));
}

# ADD:G.B @-Rn, Rd
:ADDG.B @-ea_reg,op_reg is ea=0b1011 & op_code=0b00100 & Sz=0 & ea_reg & op_reg
{
    local addr:3  = zext(ea_reg - 1);# pre-decrement (byte)
    local val:1    = *[ram]:1 addr;
    ea_reg = ea_reg - 1;
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 + val));
}

# ADD:G.B @Rn+, Rd
:ADDG.B @ea_reg+,op_reg is ea=0b1100 & op_code=0b00100 & Sz=0 & ea_reg & op_reg
{
    local addr:3  = zext(ea_reg);        # use original Rn
    local val:1    = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 + val));
	ea_reg = ea_reg + 1;
}

# ADD:G.B @aa:8, Rd
:ADDG.B @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b00100 & Sz=0 & disp8 & op_reg
{
    local addr:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:1    = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 + val));
}

# ADD:G.B @aa:16, Rd
:ADDG.B @(disp16_32),op_reg_32  is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b00100 & Sz_32=0 & disp16_32 & op_reg_32
{
    local addr:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:1    = *[ram]:1 addr;
    op_reg_32 = (op_reg_32 & 0xFF00) | zext((op_reg_32:1 + val));
}

# ADD:G.B #xx:8, Rd
:ADDG.B "#"imm8,op_reg is ea=0b0000 & ea_reg=0b100 & op_code=0b00100 & Sz=0 & imm8 & op_reg
{
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 + imm8:1));
}

# TODO: REWRITE BELOW THIS TO BETTER FORMATTING

# ADD:G.W <EAs>, Rd row

# ADD:G.W Rn, Rd
:ADDG.W ""^ea_reg^", "^op_reg^"" is ea=0b1010 & op_code=0b00100 & Sz=1 & ea_reg & op_reg
{
    local val16:2    = ea_reg;
    local result16:2 = op_reg + val16;
    op_reg = result16;
}

# ADD:G.W @Rn, Rd
:ADDG.W "@"^ea_reg^", "^op_reg^"" is ea=0b1101 & op_code=0b00100 & Sz=1 & ea_reg & op_reg
{
    local addr24:3 = zext(ea_reg);        # address from Rn
    local val:2   = *[ram]:2 addr24;     # fetch byte
    local result:2 = op_reg + val;    # add to Rd
    op_reg = result;
}

# ADD:G.W @(d:8,Rn), Rd
:ADDG.W "@("^disp8^","^ea_reg^"), "^op_reg^"" is ea=0b1110 & op_code=0b00100 & Sz=1 & ea_reg & disp8 & op_reg
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    local result:2  = op_reg + val;
    op_reg = result;
}

# ADD:G.W @(d:16,Rn), Rd
:ADDG.W "@("^disp16_32^","^ea_reg_32^"), "^op_reg_32^"" is ea_32=0b1111 & op_code_32=0b00100 & Sz_32=1 & ea_reg_32 & disp16_32 & op_reg_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    local result:2  = op_reg_32 + val;
    op_reg_32 = result;
}

# ADD:G.W @-Rn, Rd
:ADDG.W "@-"^ea_reg^", "^op_reg^"" is ea=0b1011 & op_code=0b00100 & Sz=1 & ea_reg & op_reg
{
    local temp_ea:2 = ea_reg - 2;         # pre-decrement (word)
    local addr24:3  = zext(temp_ea);
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg + val;
    op_reg = result;
    ea_reg = temp_ea;                     # write back updated Rn
}

# ADD:G.W @Rn+, Rd
:ADDG.W "@"^ea_reg^"+, "^op_reg^"" is ea=0b1100 & op_code=0b00100 & Sz=1 & ea_reg & op_reg
{
    local addr24:3  = zext(ea_reg);        # use original Rn
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg + val;
    op_reg = result;

    local new_ea:2 = ea_reg + 2;           # post-increment (word)
    ea_reg = new_ea;
}

# ADD:G.W @aa:8, Rd
:ADDG.W "@("^disp8^"), "^op_reg^"" is ea=0b0000 & ea_reg=0b101 & op_code=0b00100 & Sz=1 & disp8 & op_reg
{
    local addr24:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg + val;
    op_reg = result;
}

# ADD:G.W @aa:16, Rd
:ADDG.W "@("^disp16_32^"), "^op_reg_32^"" is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b00100 & Sz_32=1 & disp16_32 & op_reg_32
{
    local addr24:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg_32 + val;
    op_reg_32 = result;
}

# ADD:G.W #xx:16, Rd
:ADDG.W "#"^imm16_32^", "^op_reg_32^"" is ea_32=0b0000 & ea_reg_32=0b100 & op_code_32=0b00100 & Sz_32=1 & imm16_32 & op_reg_32
{
    local val:2    = imm16_32:2;
    local result:2 = op_reg_32 + val;
    op_reg_32 = result;
}


#Add:Q.B #1 row

# ADD:Q.B #1, Rn
:ADDQ.B "#"1,ea_reg is ea=0b1010 & lo_bit=0b00001000 & Sz=0 & ea_reg
{
    local result8:1 = ea_reg:1 + 1;
    ea_reg = (ea_reg & 0xFF00) | zext(result8);
}

# ADD:Q.B #1, @Rn
:ADDQ.B "#1, @"^ea_reg^"" is ea=0b1101 & lo_bit=0b00001000 & Sz=0 & ea_reg
{
    local addr24:3  = zext(ea_reg);
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 + 1;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #1, @(d:8,Rn)
:ADDQ.B "#1, @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00001000 & Sz=0 & ea_reg & disp8
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    val8 = val8 + 1;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #1, @(d:16,Rn)
:ADDQ.B "#1, @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00001000 & Sz_32=0 & ea_reg_32 & disp16_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    val8 = val8 + 1;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #1, @-Rn
:ADDQ.B "#1, @-"^ea_reg^"" is ea=0b1011 & lo_bit=0b00001000 & Sz=0 & ea_reg
{
    local temp_ea:2 = ea_reg - 1;       # pre-decrement (byte)
    local addr24:3  = zext(temp_ea);
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 + 1;
    *[ram]:1 addr24 = val8;
    ea_reg = temp_ea;                   # write back updated Rn
}

# ADD:Q.B #1, @Rn+
:ADDQ.B "#1, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00001000 & Sz=0 & ea_reg
{
    local addr24:3  = zext(ea_reg);     # use original Rn
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 + 1;
    *[ram]:1 addr24 = val8;

    local new_ea:2 = ea_reg + 1;        # post-increment (byte)
    ea_reg = new_ea;
}

# ADD:Q.B #1, @aa:8
:ADDQ.B "#1, @("^disp8^")" is ea=0b0000 & ea_reg=0b101 & lo_bit=0b00001000 & Sz=0 & disp8
{
    local addr24:3 = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val8:1   = *[ram]:1 addr24;
    val8 = val8 + 1;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #1, @aa:16
:ADDQ.B "#1, @("^disp16_32^")" is ea_32=0b0001 & ea_reg_32=0b101 & lo_bit_32=0b00001000 & Sz_32=0 & disp16_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val8:1   = *[ram]:1 addr24;
    val8 = val8 + 1;
    *[ram]:1 addr24 = val8;
}


#Add:Q.W #1 row

# ADD:Q.W #1, Rn
:ADDQ.W "#1, "^ea_reg^"" is ea=0b1010 & lo_bit=0b00001000 & Sz=1 & ea_reg
{
    local result:2 = ea_reg:2 + 1;
    ea_reg = result;
}

# ADD:Q.W #1, @Rn
:ADDQ.W "#1, @"^ea_reg^"" is ea=0b1101 & lo_bit=0b00001000 & Sz=1 & ea_reg
{
    local addr24:3  = zext(ea_reg);
    local val:2    = *[ram]:2 addr24;
    val = val + 1;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #1, @(d:8,Rn)
:ADDQ.W "#1, @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00001000 & Sz=1 & ea_reg & disp8
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    val = val + 1;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #1, @(d:16,Rn)
:ADDQ.W "#1, @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00001000 & Sz_32=1 & ea_reg_32 & disp16_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    val = val + 1;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #1, @-Rn
:ADDQ.W "#1, @-"^ea_reg^"" is ea=0b1011 & lo_bit=0b00001000 & Sz=1 & ea_reg
{
    local temp_ea:2 = ea_reg - 2;       # pre-decrement (word)
    local addr24:3  = zext(temp_ea);
    local val:2    = *[ram]:2 addr24;
    val = val + 1;
    *[ram]:2 addr24 = val;
    ea_reg = temp_ea;                   # write back updated Rn
}

# ADD:Q.W #1, @Rn+
:ADDQ.W "#1, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00001000 & Sz=1 & ea_reg
{
    local addr24:3  = zext(ea_reg);     # use original Rn
    local val:2    = *[ram]:2 addr24;
    val = val + 1;
    *[ram]:2 addr24 = val;

    local new_ea:2 = ea_reg + 2;        # post-increment (byte)
    ea_reg = new_ea;
}

# ADD:Q.W #1, @aa:8
:ADDQ.W "#1, @("^disp8^")" is ea=0b0000 & ea_reg=0b101 & lo_bit=0b00001000 & Sz=1 & disp8
{
    local addr24:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2   = *[ram]:2 addr24;
    val = val + 1;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #1, @aa:16
:ADDQ.W "#1, @("^disp16_32^")" is ea_32=0b0001 & ea_reg_32=0b101 & lo_bit_32=0b00001000 & Sz_32=1 & disp16_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val:2   = *[ram]:2 addr24;
    val = val + 1;
    *[ram]:2 addr24 = val;
}

#TODO: VERIFY EVERYTHING BELOW THIS:
#Add:Q.B #2 row

# ADD:Q.B #2, Rn
:ADDQ.B "#2, "^ea_reg^"" is ea=0b1010 & lo_bit=0b00001001 & Sz=0 & ea_reg
{
    local result8:1 = ea_reg:1 + 2;
    ea_reg = (ea_reg & 0xFF00) | zext(result8);
}

# ADD:Q.B #2, @Rn
:ADDQ.B "#2, @"^ea_reg^"" is ea=0b1101 & lo_bit=0b00001001 & Sz=0 & ea_reg
{
    local addr24:3  = zext(ea_reg);
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 + 2;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #2, @(d:8,Rn)
:ADDQ.B "#2, @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00001001 & Sz=0 & ea_reg & disp8
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    val8 = val8 + 2;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #2, @(d:16,Rn)
:ADDQ.B "#2, @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00001001 & Sz_32=0 & ea_reg_32 & disp16_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    val8 = val8 + 2;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #2, @-Rn
:ADDQ.B "#2, @-"^ea_reg^"" is ea=0b1011 & lo_bit=0b00001001 & Sz=0 & ea_reg
{
    local temp_ea:2 = ea_reg - 1;       # pre-decrement (byte)
    local addr24:3  = zext(temp_ea);
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 + 2;
    *[ram]:1 addr24 = val8;
    ea_reg = temp_ea;                   # write back updated Rn
}

# ADD:Q.B #2, @Rn+
:ADDQ.B "#2, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00001001 & Sz=0 & ea_reg
{
    local addr24:3  = zext(ea_reg);     # use original Rn
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 + 2;
    *[ram]:1 addr24 = val8;

    local new_ea:2 = ea_reg + 1;        # post-increment (byte)
    ea_reg = new_ea;
}

# ADD:Q.B #2, @aa:8
:ADDQ.B "#2, @("^disp8^")" is ea=0b0000 & ea_reg=0b101 & lo_bit=0b00001001 & Sz=0 & disp8
{
    local addr24:3 = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val8:1   = *[ram]:1 addr24;
    val8 = val8 + 2;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #2, @aa:16
:ADDQ.B "#2, @("^disp16_32^")" is ea_32=0b0001 & ea_reg_32=0b101 & lo_bit_32=0b00001001 & Sz_32=0 & disp16_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val8:1   = *[ram]:1 addr24;
    val8 = val8 + 2;
    *[ram]:1 addr24 = val8;
}


#Add:Q.W #2 row

# ADD:Q.W #2, Rn
:ADDQ.W "#2, "^ea_reg^"" is ea=0b1010 & lo_bit=0b00001001 & Sz=1 & ea_reg
{
    local result:2 = ea_reg:2 + 2;
    ea_reg = result;
}

# ADD:Q.W #2, @Rn
:ADDQ.W "#2, @"^ea_reg^"" is ea=0b1101 & lo_bit=0b00001001 & Sz=1 & ea_reg
{
    local addr24:3  = zext(ea_reg);
    local val:2    = *[ram]:2 addr24;
    val = val + 2;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #2, @(d:8,Rn)
:ADDQ.W "#2, @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00001001 & Sz=1 & ea_reg & disp8
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    val = val + 2;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #2, @(d:16,Rn)
:ADDQ.W "#2, @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00001001 & Sz_32=1 & ea_reg_32 & disp16_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    val = val + 2;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #2, @-Rn
:ADDQ.W "#2, @-"^ea_reg^"" is ea=0b1011 & lo_bit=0b00001001 & Sz=1 & ea_reg
{
    local temp_ea:2 = ea_reg - 2;       # pre-decrement (word)
    local addr24:3  = zext(temp_ea);
    local val:2    = *[ram]:2 addr24;
    val = val + 2;
    *[ram]:2 addr24 = val;
    ea_reg = temp_ea;                   # write back updated Rn
}

# ADD:Q.W #2, @Rn+
:ADDQ.W "#2, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00001001 & Sz=1 & ea_reg
{
    local addr24:3  = zext(ea_reg);     # use original Rn
    local val:2    = *[ram]:2 addr24;
    val = val + 2;
    *[ram]:2 addr24 = val;

    local new_ea:2 = ea_reg + 2;        # post-increment (word)
    ea_reg = new_ea;
}

# ADD:Q.W #2, @aa:8
:ADDQ.W "#2, @("^disp8^")" is ea=0b0000 & ea_reg=0b101 & lo_bit=0b00001001 & Sz=1 & disp8
{
    local addr24:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2   = *[ram]:2 addr24;
    val = val + 2;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #2, @aa:16
:ADDQ.W "#2, @("^disp16_32^")" is ea_32=0b0001 & ea_reg_32=0b101 & lo_bit_32=0b00001001 & Sz_32=1 & disp16_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val:2   = *[ram]:2 addr24;
    val = val + 2;
    *[ram]:2 addr24 = val;
}


#Add:Q.B #-1 row

# ADD:Q.B #-1, Rn
:ADDQ.B "#-1, "^ea_reg^"" is ea=0b1010 & lo_bit=0b00001100 & Sz=0 & ea_reg
{
    local result8:1 = ea_reg:1 - 1;
    ea_reg = (ea_reg & 0xFF00) | zext(result8);
}

# ADD:Q.B #-1, @Rn
:ADDQ.B "#-1, @"^ea_reg^"" is ea=0b1101 & lo_bit=0b00001100 & Sz=0 & ea_reg
{
    local addr24:3  = zext(ea_reg);
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 - 1;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #-1, @(d:8,Rn)
:ADDQ.B "#-1, @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00001100 & Sz=0 & ea_reg & disp8
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    val8 = val8 - 1;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #-1, @(d:16,Rn)
:ADDQ.B "#-1, @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00001100 & Sz_32=0 & ea_reg_32 & disp16_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    val8 = val8 - 1;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #-1, @-Rn
:ADDQ.B "#-1, @-"^ea_reg^"" is ea=0b1011 & lo_bit=0b00001100 & Sz=0 & ea_reg
{
    local temp_ea:2 = ea_reg - 1;       # pre-decrement (byte)
    local addr24:3  = zext(temp_ea);
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 - 1;
    *[ram]:1 addr24 = val8;
    ea_reg = temp_ea;                   # write back updated Rn
}

# ADD:Q.B #-1, @Rn+
:ADDQ.B "#-1, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00001100 & Sz=0 & ea_reg
{
    local addr24:3  = zext(ea_reg);     # use original Rn
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 - 1;
    *[ram]:1 addr24 = val8;

    local new_ea:2 = ea_reg + 1;        # post-increment (byte)
    ea_reg = new_ea;
}

# ADD:Q.B #-1, @aa:8
:ADDQ.B "#-1, @("^disp8^")" is ea=0b0000 & ea_reg=0b101 & lo_bit=0b00001100 & Sz=0 & disp8
{
    local addr24:3 = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val8:1   = *[ram]:1 addr24;
    val8 = val8 - 1;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #-1, @aa:16
:ADDQ.B "#-1, @("^disp16_32^")" is ea_32=0b0001 & ea_reg_32=0b101 & lo_bit_32=0b00001100 & Sz_32=0 & disp16_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val8:1   = *[ram]:1 addr24;
    val8 = val8 - 1;
    *[ram]:1 addr24 = val8;
}


#Add:Q.W #-1 row

# ADD:Q.W #-1, Rn
:ADDQ.W "#-1, "^ea_reg^"" is ea=0b1010 & lo_bit=0b00001100 & Sz=1 & ea_reg
{
    local result:2 = ea_reg:2 - 1;
    ea_reg = result;
}

# ADD:Q.W #-1, @Rn
:ADDQ.W "#-1, @"^ea_reg^"" is ea=0b1101 & lo_bit=0b00001100 & Sz=1 & ea_reg
{
    local addr24:3  = zext(ea_reg);
    local val:2    = *[ram]:2 addr24;
    val = val - 1;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #-1, @(d:8,Rn)
:ADDQ.W "#-1, @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00001100 & Sz=1 & ea_reg & disp8
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    val = val - 1;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #-1, @(d:16,Rn)
:ADDQ.W "#-1, @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00001100 & Sz_32=1 & ea_reg_32 & disp16_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    val = val - 1;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #-1, @-Rn
:ADDQ.W "#-1, @-"^ea_reg^"" is ea=0b1011 & lo_bit=0b00001100 & Sz=1 & ea_reg
{
    local temp_ea:2 = ea_reg - 2;       # pre-decrement (word)
    local addr24:3  = zext(temp_ea);
    local val:2    = *[ram]:2 addr24;
    val = val - 1;
    *[ram]:2 addr24 = val;
    ea_reg = temp_ea;                   # write back updated Rn
}

# ADD:Q.W #-1, @Rn+
:ADDQ.W "#-1, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00001100 & Sz=1 & ea_reg
{
    local addr24:3  = zext(ea_reg);     # use original Rn
    local val:2    = *[ram]:2 addr24;
    val = val - 1;
    *[ram]:2 addr24 = val;

    local new_ea:2 = ea_reg + 2;        # post-increment (byte)
    ea_reg = new_ea;
}

# ADD:Q.W #-1, @aa:8
:ADDQ.W "#-1, @("^disp8^")" is ea=0b0000 & ea_reg=0b101 & lo_bit=0b00001100 & Sz=1 & disp8
{
    local addr24:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2   = *[ram]:2 addr24;
    val = val - 1;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #-1, @aa:16
:ADDQ.W "#-1, @("^disp16_32^")" is ea_32=0b0001 & ea_reg_32=0b101 & lo_bit_32=0b00001100 & Sz_32=1 & disp16_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val:2   = *[ram]:2 addr24;
    val = val - 1;
    *[ram]:2 addr24 = val;
}


#Add:Q.B #-2 row

# ADD:Q.B #-2, Rn
:ADDQ.B "#-2, "^ea_reg^"" is ea=0b1010 & lo_bit=0b00001101 & Sz=0 & ea_reg
{
    local result8:1 = ea_reg:1 - 2;
    ea_reg = (ea_reg & 0xFF00) | zext(result8);
}

# ADD:Q.B #-2, @Rn
:ADDQ.B "#-2, @"^ea_reg^"" is ea=0b1101 & lo_bit=0b00001101 & Sz=0 & ea_reg
{
    local addr24:3  = zext(ea_reg);
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 - 2;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #-2, @(d:8,Rn)
:ADDQ.B "#-2, @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00001101 & Sz=0 & ea_reg & disp8
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    val8 = val8 - 2;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #-2, @(d:16,Rn)
:ADDQ.B "#-2, @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00001101 & Sz_32=0 & ea_reg_32 & disp16_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    val8 = val8 - 2;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #-2, @-Rn
:ADDQ.B "#-2, @-"^ea_reg^"" is ea=0b1011 & lo_bit=0b00001101 & Sz=0 & ea_reg
{
    local temp_ea:2 = ea_reg - 1;       # pre-decrement (byte)
    local addr24:3  = zext(temp_ea);
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 - 2;
    *[ram]:1 addr24 = val8;
    ea_reg = temp_ea;                   # write back updated Rn
}

# ADD:Q.B #-2, @Rn+
:ADDQ.B "#-2, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00001101 & Sz=0 & ea_reg
{
    local addr24:3  = zext(ea_reg);     # use original Rn
    local val8:1    = *[ram]:1 addr24;
    val8 = val8 - 2;
    *[ram]:1 addr24 = val8;

    local new_ea:2 = ea_reg + 1;        # post-increment (byte)
    ea_reg = new_ea;
}

# ADD:Q.B #-2, @aa:8
:ADDQ.B "#-2, @("^disp8^")" is ea=0b0000 & ea_reg=0b101 & lo_bit=0b00001101 & Sz=0 & disp8
{
    local addr24:3 = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val8:1   = *[ram]:1 addr24;
    val8 = val8 - 2;
    *[ram]:1 addr24 = val8;
}

# ADD:Q.B #-2, @aa:16
:ADDQ.B "#-2, @("^disp16_32^")" is ea_32=0b0001 & ea_reg_32=0b101 & lo_bit_32=0b00001101 & Sz_32=0 & disp16_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val8:1   = *[ram]:1 addr24;
    val8 = val8 - 2;
    *[ram]:1 addr24 = val8;
}


#Add:Q.W #-2 row

# ADD:Q.W #-2, Rn
:ADDQ.W "#-2, "^ea_reg^"" is ea=0b1010 & lo_bit=0b00001101 & Sz=1 & ea_reg
{
    local result:2 = ea_reg:2 - 2;
    ea_reg = result;
}

# ADD:Q.W #-2, @Rn
:ADDQ.W "#-2, @"^ea_reg^"" is ea=0b1101 & lo_bit=0b00001101 & Sz=1 & ea_reg
{
    local addr24:3  = zext(ea_reg);
    local val:2    = *[ram]:2 addr24;
    val = val - 2;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #-2, @(d:8,Rn)
:ADDQ.W "#-2, @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00001101 & Sz=1 & ea_reg & disp8
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    val = val - 2;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #-2, @(d:16,Rn)
:ADDQ.W "#-2, @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00001101 & Sz_32=1 & ea_reg_32 & disp16_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    val = val - 2;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #-2, @-Rn
:ADDQ.W "#-2, @-"^ea_reg^"" is ea=0b1011 & lo_bit=0b00001101 & Sz=1 & ea_reg
{
    local temp_ea:2 = ea_reg - 2;       # pre-decrement (word)
    local addr24:3  = zext(temp_ea);
    local val:2    = *[ram]:2 addr24;
    val = val - 2;
    *[ram]:2 addr24 = val;
    ea_reg = temp_ea;                   # write back updated Rn
}

# ADD:Q.W #-2, @Rn+
:ADDQ.W "#-2, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00001101 & Sz=1 & ea_reg
{
    local addr24:3  = zext(ea_reg);     # use original Rn
    local val:2    = *[ram]:2 addr24;
    val = val - 2;
    *[ram]:2 addr24 = val;

    local new_ea:2 = ea_reg + 2;        # post-increment (byte)
    ea_reg = new_ea;
}

# ADD:Q.W #-2, @aa:8
:ADDQ.W "#-2, @("^disp8^")" is ea=0b0000 & ea_reg=0b101 & lo_bit=0b00001101 & Sz=1 & disp8
{
    local addr24:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2   = *[ram]:2 addr24;
    val = val - 2;
    *[ram]:2 addr24 = val;
}

# ADD:Q.W #-2, @aa:16
:ADDQ.W "#-2, @("^disp16_32^")" is ea_32=0b0001 & ea_reg_32=0b101 & lo_bit_32=0b00001101 & Sz_32=1 & disp16_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val:2   = *[ram]:2 addr24;
    val = val - 2;
    *[ram]:2 addr24 = val;
}


#ADDS.B Row

# ADDS.B Rn, Rd
:ADDS.B ""^ea_reg^", "^op_reg^"" is ea=0b1010 & op_code=0b00101 & Sz=0 & ea_reg & op_reg
{
    local val:1    = ea_reg:1;
    local result:1 = op_reg:1 + val;
    op_reg = (op_reg & 0xFF00) | zext(result);
}

# ADDS.B @Rn, Rd
:ADDS.B "@"^ea_reg^", "^op_reg^"" is ea=0b1101 & op_code=0b00101 & Sz=0 & ea_reg & op_reg
{
    local addr24:3  = zext(ea_reg);
    local val8:1    = *[ram]:1 addr24;
    local result8:1 = op_reg:1 + val8;
    op_reg = (op_reg & 0xFF00) | zext(result8);
}

# ADDS.B @(d:8,Rn), Rd
:ADDS.B "@("^disp8^","^ea_reg^"), "^op_reg^"" is ea=0b1110 & op_code=0b00101 & Sz=0 & ea_reg & disp8 & op_reg
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    local result8:1  = op_reg:1 + val8;
    op_reg = (op_reg & 0xFF00) | zext(result8);
}

# ADDS.B @(d:16,Rn), Rd
:ADDS.B "@("^disp16_32^","^ea_reg_32^"), "^op_reg_32^"" is ea_32=0b1111 & op_code_32=0b00101 & Sz_32=0 & ea_reg_32 & disp16_32 & op_reg_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val8:1     = *[ram]:1 addr24;
    local result8:1  = op_reg_32:1 + val8;
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(result8);
}

# ADDS.B @-Rn, Rd
:ADDS.B "@-"^ea_reg^", "^op_reg^"" is ea=0b1011 & op_code=0b00101 & Sz=0 & ea_reg & op_reg
{
    local temp_ea:2  = ea_reg - 1;           # pre-decrement (byte)
    local addr24:3   = zext(temp_ea);
    local val8:1     = *[ram]:1 addr24;
    local result8:1  = op_reg:1 + val8;
    op_reg = (op_reg & 0xFF00) | zext(result8);
    ea_reg = temp_ea;                        # write back updated Rn
}

# ADDS.B @Rn+, Rd
:ADDS.B "@"^ea_reg^"+, "^op_reg^"" is ea=0b1100 & op_code=0b00101 & Sz=0 & ea_reg & op_reg
{
    local addr24:3   = zext(ea_reg);         # use original Rn
    local val8:1     = *[ram]:1 addr24;
    local result8:1  = op_reg:1 + val8;
    op_reg = (op_reg & 0xFF00) | zext(result8);

    local new_ea:2 = ea_reg + 1;             # post-increment (byte)
    ea_reg = new_ea;
}

# ADDS.B @aa:8, Rd
:ADDS.B "@("^disp8^"), "^op_reg^"" is ea=0b0000 & ea_reg=0b101 & op_code=0b00101 & Sz=0 & disp8 & op_reg
{
    local addr24:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val8:1    = *[ram]:1 addr24;
    local result8:1 = op_reg:1 + val8;
    op_reg = (op_reg & 0xFF00) | zext(result8);
}

# ADDS.B @aa:16, Rd
:ADDS.B "@("^disp16_32^"), "^op_reg_32^"" is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b00101 & Sz_32=0 & disp16_32 & op_reg_32
{
    local addr24:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val8:1    = *[ram]:1 addr24;
    local result8:1 = op_reg_32:1 + val8;
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(result8);
}

# ADDS.B #xx:8, Rd
:ADDS.B "#"^imm8^", "^op_reg^"" is ea=0b0000 & ea_reg=0b100 & op_code=0b00101 & Sz=0 & imm8 & op_reg
{
    local val8:1    = imm8:1;
    local result8:1 = op_reg:1 + val8;
    op_reg = (op_reg & 0xFF00) | zext(result8);
}


#ADDS.W Row

# ADDS.W Rn, Rd
:ADDS.W ""^ea_reg^", "^op_reg^"" is ea=0b1010 & op_code=0b00101 & Sz=1 & ea_reg & op_reg
{
    local val:2    = ea_reg;
    local result:2 = op_reg + val;
    op_reg = result;
}

# ADDS.W @Rn, Rd
:ADDS.W "@"^ea_reg^", "^op_reg^"" is ea=0b1101 & op_code=0b00101 & Sz=1 & ea_reg & op_reg
{
    local addr24:3  = zext(ea_reg);
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg + val;
    op_reg = result;
}

# ADDS.W @(d:8,Rn), Rd
:ADDS.W "@("^disp8^","^ea_reg^"), "^op_reg^"" is ea=0b1110 & op_code=0b00101 & Sz=1 & ea_reg & disp8 & op_reg
{
    local base24:3   = zext(ea_reg);
    local offset24:3 = sext(disp8:1);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    local result:2  = op_reg + val;
    op_reg = result;
}

# ADDS.W @(d:16,Rn), Rd
:ADDS.W "@("^disp16_32^","^ea_reg_32^"), "^op_reg_32^"" is ea_32=0b1111 & op_code_32=0b00101 & Sz_32=1 & ea_reg_32 & disp16_32 & op_reg_32
{
    local base24:3   = zext(ea_reg_32);
    local offset24:3 = sext(disp16_32:2);
    local addr24:3   = base24 + offset24;
    local val:2     = *[ram]:2 addr24;
    local result:2  = op_reg_32 + val;
    op_reg_32 = result;
}

# ADDS.W @-Rn, Rd
:ADDS.W "@-"^ea_reg^", "^op_reg^"" is ea=0b1011 & op_code=0b00101 & Sz=1 & ea_reg & op_reg
{
    local temp_ea:2  = ea_reg - 2;           # pre-decrement (word)
    local addr24:3   = zext(temp_ea);
    local val:2     = *[ram]:2 addr24;
    local result:2  = op_reg + val;
    op_reg = result;
    ea_reg = temp_ea;                        # write back updated Rn
}

# ADDS.W @Rn+, Rd
:ADDS.W "@"^ea_reg^"+, "^op_reg^"" is ea=0b1100 & op_code=0b00101 & Sz=1 & ea_reg & op_reg
{
    local addr24:3   = zext(ea_reg);         # use original Rn
    local val:2     = *[ram]:2 addr24;
    local result:2  = op_reg + val;
    op_reg = result;

    local new_ea:2 = ea_reg + 2;             # post-increment (word)
    ea_reg = new_ea;
}

# ADDS.W @aa:8, Rd
:ADDS.W "@("^disp8^"), "^op_reg^"" is ea=0b0000 & ea_reg=0b101 & op_code=0b00101 & Sz=1 & disp8 & op_reg
{
    local addr24:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg + val;
    op_reg = result;
}

# ADDS.W @aa:16, Rd
:ADDS.W "@("^disp16_32^"), "^op_reg_32^"" is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b00101 & Sz_32=1 & disp16_32 & op_reg_32
{
    local addr24:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg_32 + val;
    op_reg_32 = result;
}

# ADDS.W #xx:16, Rd
:ADDS.W "#"^imm16_32^", "^op_reg_32^"" is ea_32=0b0000 & ea_reg_32=0b100 & op_code_32=0b00101 & Sz_32=1 & imm16_32 & op_reg_32
{
    local val:2    = imm16_32:2;
    local result:2 = op_reg_32 + val;
    op_reg_32 = result;
}


# ADDX.B Row

# ADDX.B Rn, Rd
:ADDX.B ""^ea_reg^", "^op_reg^"" is ea=0b1010 & op_code=0b10100 & Sz=0 & ea_reg & op_reg
{
    local val:1    = ea_reg:1;
    local result:1 = op_reg:1 + val;
    op_reg = (op_reg & 0xFF00) | zext(result);
}

# ADDX.B @Rn, Rd
:ADDX.B "@"^ea_reg^", "^op_reg^"" is ea=0b1101 & op_code=0b10100 & Sz=0 & ea_reg & op_reg
{
    local addr24:3  = zext(ea_reg);
    local val:1     = *[ram]:1 addr24;
    local result:1  = op_reg:1 + val;
    op_reg = (op_reg & 0xFF00) | zext(result);
}

# ADDX.B @(d:8,Rn), Rd
:ADDX.B "@("^disp8^","^ea_reg^"), "^op_reg^"" is ea=0b1110 & op_code=0b10100 & Sz=0 & ea_reg & disp8 & op_reg
{
    local addr24:3  = zext(ea_reg) + sext(disp8:1);
    local val:1     = *[ram]:1 addr24;
    local result:1  = op_reg:1 + val;
    op_reg = (op_reg & 0xFF00) | zext(result);
}

# ADDX.B @(d:16,Rn), Rd
:ADDX.B "@("^disp16_32^","^ea_reg_32^"), "^op_reg_32^"" is ea_32=0b1111 & op_code_32=0b10100 & Sz_32=0 & ea_reg_32 & disp16_32 & op_reg_32
{
    local addr24:3  = zext(ea_reg_32) + sext(disp16_32:2);
    local val:1     = *[ram]:1 addr24;
    local result:1  = op_reg_32:1 + val;
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(result);
}

# ADDX.B @-Rn, Rd
:ADDX.B "@-"^ea_reg^", "^op_reg^"" is ea=0b1011 & op_code=0b10100 & Sz=0 & ea_reg & op_reg
{
    local temp_ea:2 = ea_reg - 1;
    local addr24:3 = zext(temp_ea);
    local val:1     = *[ram]:1 addr24;
    local result:1  = op_reg:1 + val;
    op_reg = (op_reg & 0xFF00) | zext(result);
    ea_reg = temp_ea;
}

# ADDX.B @Rn+, Rd
:ADDX.B "@"^ea_reg^"+, "^op_reg^"" is ea=0b1100 & op_code=0b10100 & Sz=0 & ea_reg & op_reg
{
	local addr24:3 = zext(ea_reg);
    local val:1     = *[ram]:1 addr24;
    local result:1  = op_reg:1 + val;
    op_reg = (op_reg & 0xFF00) | zext(result);
    ea_reg = ea_reg + 1;
}

# ADDX.B @aa:8, Rd
:ADDX.B "@("^disp8^"), "^op_reg^"" is ea=0b0000 & ea_reg=0b101 & op_code=0b10100 & Sz=0 & disp8 & op_reg
{
	local addr24:3 = 0xFF00 | zext(disp8:1);
    local val:1     = *[ram]:1 addr24;
    local result:1  = op_reg:1 + val;
    op_reg = (op_reg & 0xFF00) | zext(result);
}

# ADDX.B @aa:16, Rd
:ADDX.B "@("^disp16_32^"), "^op_reg_32^"" is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b10100 & Sz_32=0 & disp16_32 & op_reg_32
{
	local addr24:3 = zext(disp16_32:2);
    local val:1     = *[ram]:1 addr24;
    local result:1  = op_reg_32:1 + val;
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(result);
}

# ADDX.B #xx:8, Rd
:ADDX.B "#"^imm8^", "^op_reg^"" is ea=0b0000 & ea_reg=0b100 & op_code=0b10100 & Sz=0 & imm8 & op_reg
{
    local result:1 = op_reg:1 + imm8:1;
    op_reg = (op_reg & 0xFF00) | zext(result);
}


# ADDX.W Row

# ADDX.W Rn, Rd
:ADDX.W ""^ea_reg^", "^op_reg^"" is ea=0b1010 & op_code=0b10100 & Sz=1 & ea_reg & op_reg
{
    local val:2    = ea_reg;
    local result:2 = op_reg + val;
    op_reg = result;
}

# ADDX.W @Rn, Rd
:ADDX.W "@"^ea_reg^", "^op_reg^"" is ea=0b1101 & op_code=0b10100 & Sz=1 & ea_reg & op_reg
{
	local addr24:3 = zext(ea_reg);
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg + val;
    op_reg = result;
}

# ADDX.W @(d:8,Rn), Rd
:ADDX.W "@("^disp8^","^ea_reg^"), "^op_reg^"" is ea=0b1110 & op_code=0b10100 & Sz=1 & ea_reg & disp8 & op_reg
{
	local base24:3 = zext(ea_reg);
	local offset24:3 = sext(disp8:1);
	local addr24:3 = base24 + offset24;
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg + val;
    op_reg = result;
}

# ADDX.W @(d:16,Rn), Rd
:ADDX.W "@("^disp16_32^","^ea_reg_32^"), "^op_reg_32^"" is ea_32=0b1111 & op_code_32=0b10100 & Sz_32=1 & ea_reg_32 & disp16_32 & op_reg_32
{
	local base24:3 = zext(ea_reg_32);
	local offset24:3 = sext(disp16_32:2);
	local addr24:3 = base24 + offset24;
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg_32 + val;
    op_reg_32 = result;
}

# ADDX.W @-Rn, Rd
:ADDX.W "@-"^ea_reg^", "^op_reg^"" is ea=0b1011 & op_code=0b10100 & Sz=1 & ea_reg & op_reg
{
    local temp_ea:2 = ea_reg - 2;
    local addr24:3 = zext(temp_ea);
    local val:2     = *[ram]:2 addr24;
    local result:2  = op_reg + val;
    op_reg = result;
    ea_reg = temp_ea;
}

# ADDX.W @Rn+, Rd
:ADDX.W "@"^ea_reg^"+, "^op_reg^"" is ea=0b1100 & op_code=0b10100 & Sz=1 & ea_reg & op_reg
{
	local addr24:3 = zext(ea_reg);
    local val:2     = *[ram]:2 addr24;
    local result:2  = op_reg + val;
    op_reg = result;
    ea_reg = ea_reg + 2;
}

# ADDX.W @aa:8, Rd
:ADDX.W "@("^disp8^"), "^op_reg^"" is ea=0b0000 & ea_reg=0b101 & op_code=0b10100 & Sz=1 & disp8 & op_reg
{
	local addr24:3 = 0xFF00 | zext(disp8:1);
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg + val;
    op_reg = result;
}

# ADDX.W @aa:16, Rd
:ADDX.W "@("^disp16_32^"), "^op_reg_32^"" is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b10100 & Sz_32=1 & disp16_32 & op_reg_32
{
	local addr24:3 = zext(disp16_32:2);
    local val:2    = *[ram]:2 addr24;
    local result:2 = op_reg_32 + val;
    op_reg_32 = result;
}

# ADDX.W #xx:16, Rd
:ADDX.W "#"^imm16_32^", "^op_reg_32^"" is ea_32=0b0000 & ea_reg_32=0b100 & op_code_32=0b10100 & Sz_32=1 & imm16_32 & op_reg_32
{
    local result:2 = op_reg_32 + imm16_32:2;
    op_reg_32 = result;
}

# DADD/DSUB ROWs

# DADD.B Rn, Rd  (3-byte: EA + 0x00 prefix + opcode)
:DADD.B ea_reg_dadd,op_reg_dadd
  is ea_dadd=0b1010 & Sz_dadd=0 & prefix_dadd=0b00000000 &
     op_code_dadd=0b10100 & ea_reg_dadd & op_reg_dadd
{
    local src:1 = ea_reg_dadd:1;
    local dst:1 = op_reg_dadd:1;

    # --- Low nibble add ---
    local low_sum:1  = (dst & 0x0F) + (src & 0x0F) + $(C_FLAG);
    local carry_low:1 = 0;
    if low_sum > 9 goto <no_low_adjust>;
        low_sum = low_sum + 6;
        carry_low = 1;
<no_low_adjust>

    # --- High nibble add ---
    local high_sum:1 = ((dst >> 4) & 0x0F) + ((src >> 4) & 0x0F) + carry_low;
    if high_sum > 9 goto <no_high_adjust>;
        high_sum = high_sum + 6;
<no_high_adjust>

    # --- Combine nibbles into final 8-bit result ---
    local result:1 = ((high_sum << 4) & 0xF0) | (low_sum & 0x0F);

    # --- Safely write low byte back into Rd ---
    local tmp16:2 = op_reg_dadd;
    tmp16 = (tmp16 & 0xFF00) | zext(result);
    op_reg_dadd = tmp16;

    # --- Update carry flag ---
    if high_sum > 15 goto <carry_on>;
        $(C_FLAG) = 0;
        goto <carry_done>;
<carry_on>
    $(C_FLAG) = 1;
<carry_done>
}

# DSUB.B Rn, Rd  (3-byte: EA + 0x00 prefix + opcode)
:DSUB.B ea_reg_dadd,op_reg_dadd
  is ea_dadd=0b1010 & Sz_dadd=0 & prefix_dadd=0b00000000 &
     op_code_dadd=0b10110 & ea_reg_dadd & op_reg_dadd
{
    local src:1 = ea_reg_dadd:1;
    local dst:1 = op_reg_dadd:1;

    # --- Low nibble subtraction (in BCD) ---
    local low_diff:2 = zext((dst & 0x0F)) - zext((src & 0x0F)) - zext($(C_FLAG));
    local borrow_low:1 = 0;
    if low_diff > 0x0F goto <low_ok>;
        low_diff = low_diff - 6;
        borrow_low = 1;
<low_ok>

    # --- High nibble subtraction ---
    local high_diff:2 = zext((dst >> 4) & 0x0F) - zext((src >> 4) & 0x0F) - zext(borrow_low);
    local borrow_high:1 = 0;
    if high_diff > 0x0F goto <high_ok>;
        high_diff = high_diff - 6;
        borrow_high = 1;
<high_ok>

    # --- Combine nibbles into final result ---
    local tmp8:2   = ((high_diff & 0x0F) << 4) | (low_diff & 0x0F);  # 2-byte intermediate
	local result:1 = tmp8:1;

    # --- Write back to Rd (low byte only) ---
    local tmp16:2 = op_reg_dadd;
    tmp16 = (tmp16 & 0xFF00) | zext(result);
    op_reg_dadd = tmp16;

    # --- Update carry flag (C = inverted borrow) ---
    if borrow_high != 0 goto <borrowed>;
        $(C_FLAG) = 1;
        goto <done>;
<borrowed>
    $(C_FLAG) = 0;
<done>
}


# SUB.B <EAs>, Rd row

# SUB.B Rn, Rd
:SUB.B ea_reg,op_reg is ea=0b1010 & op_code=0b00110 & Sz=0 & ea_reg & op_reg
{
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 - ea_reg:1));
}

# TODO: Verify Below this line

# SUB.B @Rn, Rd
:SUB.B @ea_reg,op_reg is ea=0b1101 & op_code=0b00110 & Sz=0 & ea_reg & op_reg
{
    local addr:3 = zext(ea_reg);        # address from Rn
    local val:1   = *[ram]:1 addr;     # fetch byte Rd
    op_reg = (op_reg & 0xFF00) | zext(op_reg:1 - val);
}

# SUB.B @(d:8,Rn), Rd
:SUB.B @(disp8,ea_reg),op_reg is ea=0b1110 & op_code=0b00110 & Sz=0 & ea_reg & disp8 & op_reg
{
    local addr:3   = zext(ea_reg) + sext(disp8:1);
    local val:1     = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext(op_reg:1 - val);
}

# SUB.B @(d:16,Rn), Rd
:SUB.B @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b00110 & Sz_32=0 & ea_reg_32 & disp16_32 & op_reg_32
{
    local addr:3 = zext(ea_reg_32) + sext(disp16_32:2);
	local val:1 = *[ram]:1 addr;
	op_reg_32 = (op_reg_32 & 0xFF00) | zext((op_reg_32:1 - val));
}

# SUB.B @-Rn, Rd
:SUB.B @-ea_reg,op_reg is ea=0b1011 & op_code=0b00110 & Sz=0 & ea_reg & op_reg
{
	ea_reg = ea_reg - 1;				# pre-decrement (byte)
    local addr:3  = zext(ea_reg);         
    local val:1    = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 - val));
}

# SUB.B @Rn+, Rd
:SUB.B @ea_reg+,op_reg is ea=0b1100 & op_code=0b00110 & Sz=0 & ea_reg & op_reg
{
    local addr24:3  = zext(ea_reg);        # use original Rn
    local val:1    = *[ram]:1 addr24;
    ea_reg = ea_reg + 1;
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 - val));
}

# SUB.B @aa:8, Rd
:SUB.B @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b00110 & Sz=0 & disp8 & op_reg
{
    local addr:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:1    = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext(op_reg:1 - val);
}

# SUB.B @aa:16, Rd
:SUB.B @(disp16_32), op_reg_32 is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b00110 & Sz_32=0 & disp16_32 & op_reg_32
{
    local addr:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:1    = *[ram]:1 addr;
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(op_reg_32:1 - val);
}

# SUB.B #xx:8, Rd
:SUB.B "#"imm8,op_reg is ea=0b0000 & ea_reg=0b100 & op_code=0b00110 & Sz=0 & imm8 & op_reg
{
	op_reg = (op_reg & 0xFF00) | zext((op_reg:1 - imm8:1));
}


#TODO: Verify this
# SUB.W Row

# SUB.W Rn, Rd
:SUB.W ea_reg,op_reg is ea=0b1010 & op_code=0b00110 & Sz=1 & ea_reg & op_reg
{
    op_reg = op_reg - ea_reg;
}

# SUB.W @Rn, Rd
:SUB.W @ea_reg,op_reg is ea=0b1101 & op_code=0b00110 & Sz=1 & ea_reg & op_reg
{
    local addr:3 = zext(ea_reg);        # address from Rn
    local val:2   = *[ram]:2 addr;     # fetch byte
    op_reg = op_reg - val;
}

# SUB.W @(d:8,Rn), Rd
:SUB.W @(disp8,ea_reg),op_reg is ea=0b1110 & op_code=0b00110 & Sz=1 & ea_reg & disp8 & op_reg
{
    local addr:3   = zext(ea_reg) + sext(disp8:1);
    local val:2     = *[ram]:2 addr;
    op_reg = op_reg - val;
}

# SUB.W @(d:16,Rn), Rd
:SUB.W @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b00110 & Sz_32=1 & ea_reg_32 & disp16_32 & op_reg_32
{
    local addr:3   = zext(ea_reg_32) + sext(disp16_32:2);
    local val:2     = *[ram]:2 addr;
    op_reg_32 = op_reg_32 - val;
}

# SUB.W @-Rn, Rd
:SUB.W @-ea_reg,op_reg is ea=0b1011 & op_code=0b00110 & Sz=1 & ea_reg & op_reg
{
    ea_reg = ea_reg - 2;         # pre-decrement (word)
    local addr:3  = zext(ea_reg);
    local val:2    = *[ram]:2 addr;
    op_reg = op_reg - val;
}

# SUB.W @Rn+, Rd
:SUB.W @ea_reg+,op_reg is ea=0b1100 & op_code=0b00110 & Sz=1 & ea_reg & op_reg
{
    local addr:3  = zext(ea_reg);        # use original Rn
    local val:2    = *[ram]:2 addr;
    ea_reg = ea_reg + 2;           # post-increment (word)
    op_reg = op_reg - val;
}

# SUB.W @aa:8, Rd
:SUB.W @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b00110 & Sz=1 & disp8 & op_reg
{
    local addr:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2    = *[ram]:2 addr;
    op_reg = op_reg - val;
}

# SUB.W @aa:16, Rd
:SUB.W @(disp16_32),op_reg_32 is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b00110 & Sz_32=1 & disp16_32 & op_reg_32
{
    local addr:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:2    = *[ram]:2 addr;
    op_reg_32 = op_reg_32 - val;
}

# SUB.W #xx:16, Rd
:SUB.W "#"imm16_32,op_reg_32 is ea_32=0b0000 & ea_reg_32=0b100 & op_code_32=0b00110 & Sz_32=1 & imm16_32 & op_reg_32
{
    op_reg_32 = op_reg_32 - imm16_32:2;
}

# SUBS.B <EAs>, Rd row

# SUBS.B Rn, Rd
:SUBS.B ea_reg,op_reg is ea=0b1010 & op_code=0b00111 & Sz=0 & ea_reg & op_reg
{
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 - ea_reg:1));
}

# TODO: Verify Below this line

# SUBS.B @Rn, Rd
:SUBS.B @ea_reg,op_reg is ea=0b1101 & op_code=0b00111 & Sz=0 & ea_reg & op_reg
{
    local addr:3 = zext(ea_reg);        # address from Rn
    local val:1   = *[ram]:1 addr;     # fetch byte Rd
    op_reg = (op_reg & 0xFF00) | zext(op_reg:1 - val);
}

# SUBS.B @(d:8,Rn), Rd
:SUBS.B @(disp8,ea_reg),op_reg is ea=0b1110 & op_code=0b00111 & Sz=0 & ea_reg & disp8 & op_reg
{
    local addr:3   = zext(ea_reg) + sext(disp8:1);
    local val:1     = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext(op_reg:1 - val);
}

# SUBS.B @(d:16,Rn), Rd
:SUBS.B @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b00111 & Sz_32=0 & ea_reg_32 & disp16_32 & op_reg_32
{
    local addr:3 = zext(ea_reg_32) + sext(disp16_32:2);
	local val:1 = *[ram]:1 addr;
	op_reg_32 = (op_reg_32 & 0xFF00) | zext((op_reg_32:1 - val));
}

# SUBS.B @-Rn, Rd
:SUBS.B @-ea_reg,op_reg is ea=0b1011 & op_code=0b00111 & Sz=0 & ea_reg & op_reg
{
	ea_reg = ea_reg - 1;				# pre-decrement (byte)
    local addr:3  = zext(ea_reg);         
    local val:1    = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 - val));
}

# SUBS.B @Rn+, Rd
:SUBS.B @ea_reg+,op_reg is ea=0b1100 & op_code=0b00111 & Sz=0 & ea_reg & op_reg
{
    local addr24:3  = zext(ea_reg);        # use original Rn
    local val:1    = *[ram]:1 addr24;
    ea_reg = ea_reg + 1;
    op_reg = (op_reg & 0xFF00) | zext((op_reg:1 - val));
}

# SUBS.B @aa:8, Rd
:SUBS.B @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b00111 & Sz=0 & disp8 & op_reg
{
    local addr:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:1    = *[ram]:1 addr;
    op_reg = (op_reg & 0xFF00) | zext(op_reg:1 - val);
}

# SUBS.B @aa:16, Rd
:SUBS.B @(disp16_32), op_reg_32 is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b00111 & Sz_32=0 & disp16_32 & op_reg_32
{
    local addr:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:1    = *[ram]:1 addr;
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(op_reg_32:1 - val);
}

# SUBS.B #xx:8, Rd
:SUBS.B "#"imm8,op_reg is ea=0b0000 & ea_reg=0b100 & op_code=0b00111 & Sz=0 & imm8 & op_reg
{
	op_reg = (op_reg & 0xFF00) | zext((op_reg:1 - imm8:1));
}


# SUBS.W Row

# SUBS.W Rn, Rd
:SUBS.W ea_reg,op_reg is ea=0b1010 & op_code=0b00111 & Sz=1 & ea_reg & op_reg
{
    op_reg = op_reg - ea_reg;
}

# SUBS.W @Rn, Rd
:SUBS.W @ea_reg,op_reg is ea=0b1101 & op_code=0b00111 & Sz=1 & ea_reg & op_reg
{
    local addr:3 = zext(ea_reg);        # address from Rn
    local val:2   = *[ram]:2 addr;     # fetch byte
    op_reg = op_reg - val;
}

# SUBS.W @(d:8,Rn), Rd
:SUBS.W @(disp8,ea_reg),op_reg is ea=0b1110 & op_code=0b00111 & Sz=1 & ea_reg & disp8 & op_reg
{
    local addr:3   = zext(ea_reg) + sext(disp8:1);
    local val:2     = *[ram]:2 addr;
    op_reg = op_reg - val;
}

# SUBS.W @(d:16,Rn), Rd
:SUBS.W @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b00111 & Sz_32=1 & ea_reg_32 & disp16_32 & op_reg_32
{
    local addr:3   = zext(ea_reg_32) + sext(disp16_32:2);
    local val:2     = *[ram]:2 addr;
    op_reg_32 = op_reg_32 - val;
}

# SUBS.W @-Rn, Rd
:SUBS.W @-ea_reg,op_reg is ea=0b1011 & op_code=0b00111 & Sz=1 & ea_reg & op_reg
{
    ea_reg = ea_reg - 2;         # pre-decrement (word)
    local addr:3  = zext(ea_reg);
    local val:2    = *[ram]:2 addr;
    op_reg = op_reg - val;
}

# SUBS.W @Rn+, Rd
:SUBS.W @ea_reg+,op_reg is ea=0b1100 & op_code=0b00111 & Sz=1 & ea_reg & op_reg
{
    local addr:3  = zext(ea_reg);        # use original Rn
    local val:2    = *[ram]:2 addr;
    ea_reg = ea_reg + 2;           # post-increment (word)
    op_reg = op_reg - val;
}

# SUBS.W @aa:8, Rd
:SUBS.W @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b00111 & Sz=1 & disp8 & op_reg
{
    local addr:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2    = *[ram]:2 addr;
    op_reg = op_reg - val;
}

# SUBS.W @aa:16, Rd
:SUBS.W @(disp16_32),op_reg_32 is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b00111 & Sz_32=1 & disp16_32 & op_reg_32
{
    local addr:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:2    = *[ram]:2 addr;
    op_reg_32 = op_reg_32 - val;
}

# SUBS.W #xx:16, Rd
:SUBS.W "#"imm16_32,op_reg_32 is ea_32=0b0000 & ea_reg_32=0b100 & op_code_32=0b00111 & Sz_32=1 & imm16_32 & op_reg_32
{
    op_reg_32 = op_reg_32 - imm16_32:2;
}


#SUBX.B Row

# SUBX.B Rn, Rd
:SUBX.B ea_reg,op_reg is ea=0b1010 & op_code=0b10110 & Sz=0 & ea_reg & op_reg
{
	local result:1 = op_reg:1 - ea_reg:1 - $(C_FLAG);
    op_reg = (op_reg & 0xFF00) | zext(result);
    $(C_FLAG) = (result < 0x100);
}

# SUBX.B @Rn, Rd
:SUBX.B @ea_reg,op_reg is ea=0b1101 & op_code=0b10110 & Sz=0 & ea_reg & op_reg
{
    local addr:3  = zext(ea_reg);
    local val:1     = *[ram]:1 addr;
    local result:1  = op_reg:1 - val - $(C_FLAG);
    op_reg = (op_reg & 0xFF00) | zext(result);
    
    $(C_FLAG) = (result < 0x100);
}

# SUBX.B @(d:8,Rn), Rd
:SUBX.B @(disp8,ea_reg), op_reg is ea=0b1110 & op_code=0b10110 & Sz=0 & ea_reg & disp8 & op_reg
{
    local addr:3  = zext(ea_reg) + sext(disp8:1);
    local val:1     = *[ram]:1 addr;
    local result:1  = op_reg:1 - val - $(C_FLAG);
    op_reg = (op_reg & 0xFF00) | zext(result);
    
    $(C_FLAG) = (result < 0x100);
}

# SUBX.B @(d:16,Rn), Rd
:SUBX.B @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b10110 & Sz_32=0 & ea_reg_32 & disp16_32 & op_reg_32
{
    local addr:3  = zext(ea_reg_32) + sext(disp16_32:2);
    local val:1     = *[ram]:1 addr;
    local result:1  = op_reg_32:1 - val - $(C_FLAG);
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(result);
    
    $(C_FLAG) = (result < 0x100);
}

# SUBX.B @-Rn, Rd
:SUBX.B @-ea_reg,op_reg is ea=0b1011 & op_code=0b10110 & Sz=0 & ea_reg & op_reg
{
    ea_reg = ea_reg - 1;
    local addr:3 = zext(ea_reg);
    local val:1     = *[ram]:1 addr;
    local result:1  = op_reg:1 - val - $(C_FLAG);
    op_reg = (op_reg & 0xFF00) | zext(result);
    
    $(C_FLAG) = (result < 0x100);
}

# SUBX.B @Rn+, Rd
:SUBX.B @ea_reg+,op_reg is ea=0b1100 & op_code=0b10110 & Sz=0 & ea_reg & op_reg
{
	local addr:3 = zext(ea_reg);
    local val:1     = *[ram]:1 addr;
    local result:1  = op_reg:1 - val - $(C_FLAG);
    op_reg = (op_reg & 0xFF00) | zext(result);
    ea_reg = ea_reg + 1;
    
    $(C_FLAG) = (result < 0x100);
}

# SUBX.B @aa:8, Rd
:SUBX.B @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b10110 & Sz=0 & disp8 & op_reg
{
	local addr:3 = 0xFF00 | zext(disp8:1);
    local val:1     = *[ram]:1 addr;
    local result:1  = op_reg:1 - val - $(C_FLAG);
    op_reg = (op_reg & 0xFF00) | zext(result);
    
    $(C_FLAG) = (result < 0x100);
}

# SUBX.B @aa:16, Rd
:SUBX.B @(disp16_32),op_reg_32 is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b10110 & Sz_32=0 & disp16_32 & op_reg_32
{
	local addr:3 = zext(disp16_32:2);
    local val:1     = *[ram]:1 addr;
    local result:1  = op_reg_32:1 - val - $(C_FLAG);
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(result);
    
    $(C_FLAG) = (result < 0x100);
}

# SUBX.B #xx:8, Rd
:SUBX.B "#"imm8,op_reg is ea=0b0000 & ea_reg=0b100 & op_code=0b10110 & Sz=0 & imm8 & op_reg
{
    local result:1 = op_reg:1 - imm8:1 - $(C_FLAG);
    op_reg = (op_reg & 0xFF00) | zext(result);
    
    $(C_FLAG) = (result < 0x100);
}


# SUBX.W Row

# SUBX.W Rn, Rd
:SUBX.W ea_reg,op_reg is ea=0b1010 & op_code=0b10110 & Sz=1 & ea_reg & op_reg
{
    local val:2 = ea_reg;
    local result:2 = op_reg - val - zext($(C_FLAG));
    op_reg = result;
    
    $(C_FLAG) = (result < 0x10000);
}

# SUBX.W @Rn, Rd
:SUBX.W @ea_reg,op_reg is ea=0b1101 & op_code=0b10110 & Sz=1 & ea_reg & op_reg
{
	local addr:3 = zext(ea_reg);
    local val:2    = *[ram]:2 addr;
    local result:2 = op_reg - val - zext($(C_FLAG));
    op_reg = result;
    
    $(C_FLAG) = (result < 0x10000);
}

# SUBX.W @(d:8,Rn), Rd
:SUBX.W @(disp8,ea_reg),op_reg is ea=0b1110 & op_code=0b10110 & Sz=1 & ea_reg & disp8 & op_reg
{
	local addr:3 = zext(ea_reg) + sext(disp8:1);
    local val:2    = *[ram]:2 addr;
    local result:2 = op_reg - val - zext($(C_FLAG));
    op_reg = result;
    
    $(C_FLAG) = (result < 0x10000);
}

# SUBX.W @(d:16,Rn), Rd
:SUBX.W @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b10110 & Sz_32=1 & ea_reg_32 & disp16_32 & op_reg_32
{
	local addr:3 = zext(ea_reg_32) + sext(disp16_32:2);
    local val:2    = *[ram]:2 addr;
    local result:2 = op_reg_32 - val - zext($(C_FLAG));
    op_reg_32 = result;
    
    $(C_FLAG) = (result < 0x10000);
}

# SUBX.W @-Rn, Rd
:SUBX.W @-ea_reg,op_reg is ea=0b1011 & op_code=0b10110 & Sz=1 & ea_reg & op_reg
{
    ea_reg = ea_reg - 2;
    local addr:3 = zext(ea_reg);
    local val:2     = *[ram]:2 addr;
    local result:2  = op_reg - val - zext($(C_FLAG));
    op_reg = result;
    
    $(C_FLAG) = (result < 0x10000);
}

# SUBX.W @Rn+, Rd
:SUBX.W @ea_reg+,op_reg is ea=0b1100 & op_code=0b10110 & Sz=1 & ea_reg & op_reg
{
	local addr:3 = zext(ea_reg);
    local val:2     = *[ram]:2 addr;
    local result:2  = op_reg - val - zext($(C_FLAG));
    op_reg = result;
    ea_reg = ea_reg + 2;
    
    $(C_FLAG) = (result < 0x10000);
}

# SUBX.W @aa:8, Rd
:SUBX.W @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b10110 & Sz=1 & disp8 & op_reg
{
	local addr:3 = 0xFF00 | zext(disp8:1);
    local val:2    = *[ram]:2 addr;
    local result:2 = op_reg - val - zext($(C_FLAG));
    op_reg = result;
    
    $(C_FLAG) = (result < 0x10000);
}

# SUBX.W @aa:16, Rd
:SUBX.W @(disp16_32),op_reg_32 is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b10110 & Sz_32=1 & disp16_32 & op_reg_32
{
	local addr:3 = zext(disp16_32:2);
    local val:2    = *[ram]:2 addr;
    local result:2 = op_reg_32 - val - zext($(C_FLAG));
    op_reg_32 = result;
    
    $(C_FLAG) = (result < 0x10000);
}

# SUBX.W #xx:16, Rd
:SUBX.W "#"imm16_32,op_reg_32 is ea_32=0b0000 & ea_reg_32=0b100 & op_code_32=0b10110 & Sz_32=1 & imm16_32 & op_reg_32
{
    local result:2 = op_reg_32 - imm16_32 - zext($(C_FLAG));
    op_reg_32 = result;
    
    $(C_FLAG) = (result < 0x10000);
}


# MULXU.B <EAs>, Rd row

# MULXU.B Rn, Rd
:MULXU.B ea_reg,op_reg is ea=0b1010 & op_code=0b10101 & Sz=0 & ea_reg & op_reg
{
    op_reg = zext(op_reg:1) * zext(ea_reg:1);
}

# TODO: Verify Below this line

# MULXU.B @Rn, Rd
:MULXU.B @ea_reg,op_reg is ea=0b1101 & op_code=0b10101 & Sz=0 & ea_reg & op_reg
{
    local addr:3 = zext(ea_reg);        # address from Rn
    local val:1   = *[ram]:1 addr;     # fetch byte Rd
    op_reg =  zext(op_reg:1) * zext(val);
}

# MULXU.B @(d:8,Rn), Rd
:MULXU.B @(disp8,ea_reg),op_reg is ea=0b1110 & op_code=0b10101 & Sz=0 & ea_reg & disp8 & op_reg
{
    local addr:3   = zext(ea_reg) + sext(disp8:1);
    local val:1     = *[ram]:1 addr;
    op_reg =  zext(op_reg:1) * zext(val);
}

# MULXU.B @(d:16,Rn), Rd
:MULXU.B @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b10101 & Sz_32=0 & ea_reg_32 & disp16_32 & op_reg_32
{
    local addr:3 = zext(ea_reg_32) + sext(disp16_32:2);
	local val:1 = *[ram]:1 addr;
	op_reg_32 = zext(op_reg_32:1) * zext(val);
}

# MULXU.B @-Rn, Rd
:MULXU.B @-ea_reg,op_reg is ea=0b1011 & op_code=0b10101 & Sz=0 & ea_reg & op_reg
{
	ea_reg = ea_reg - 1;				# pre-decrement (byte)
    local addr:3  = zext(ea_reg);         
    local val:1    = *[ram]:1 addr;
    op_reg =  zext(op_reg:1) * zext(val);
}

# MULXU.B @Rn+, Rd
:MULXU.B @ea_reg+,op_reg is ea=0b1100 & op_code=0b10101 & Sz=0 & ea_reg & op_reg
{
    local addr24:3  = zext(ea_reg);        # use original Rn
    local val:1    = *[ram]:1 addr24;
    ea_reg = ea_reg + 1;
    op_reg =  zext(op_reg:1) * zext(val);
}

# MULXU.B @aa:8, Rd
:MULXU.B @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b10101 & Sz=0 & disp8 & op_reg
{
    local addr:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:1    = *[ram]:1 addr;
    op_reg =  zext(op_reg:1) * zext(val);
}

# MULXU.B @aa:16, Rd
:MULXU.B @(disp16_32), op_reg_32 is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b10101 & Sz_32=0 & disp16_32 & op_reg_32
{
    local addr:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:1    = *[ram]:1 addr;
    op_reg_32 = zext(op_reg_32:1) * zext(val);
}

# MULXU.B #xx:8, Rd
:MULXU.B "#"imm8,op_reg is ea=0b0000 & ea_reg=0b100 & op_code=0b10101 & Sz=0 & imm8 & op_reg
{
	op_reg = zext(op_reg:1) * zext(imm8:1);
}


#TODO: Verify this
# MULXU.W Row

# MULXU.W Rn, Rd
:MULXU.W ea_reg,op_reg is ea=0b1010 & op_code=0b10101 & Sz=1 & ea_reg & op_reg
{
    op_reg = op_reg * ea_reg;
}

# MULXU.W @Rn, Rd
:MULXU.W @ea_reg,op_reg is ea=0b1101 & op_code=0b10101 & Sz=1 & ea_reg & op_reg
{
    local addr:3 = zext(ea_reg);        # address from Rn
    local val:2   = *[ram]:2 addr;     # fetch word
    op_reg = op_reg * val;
}

# MULXU.W @(d:8,Rn), Rd
:MULXU.W @(disp8,ea_reg),op_reg is ea=0b1110 & op_code=0b10101 & Sz=1 & ea_reg & disp8 & op_reg
{
    local addr:3   = zext(ea_reg) + sext(disp8:1);
    local val:2     = *[ram]:2 addr;
    op_reg = op_reg * val;
}

# MULXU.W @(d:16,Rn), Rd
:MULXU.W @(disp16_32,ea_reg_32),op_reg_32 is ea_32=0b1111 & op_code_32=0b10101 & Sz_32=1 & ea_reg_32 & disp16_32 & op_reg_32
{
    local addr:3   = zext(ea_reg_32) + sext(disp16_32:2);
    local val:2     = *[ram]:2 addr;
    op_reg_32 = op_reg_32 * val;
}

# MULXU.W @-Rn, Rd
:MULXU.W @-ea_reg,op_reg is ea=0b1011 & op_code=0b10101 & Sz=1 & ea_reg & op_reg
{
    ea_reg = ea_reg - 2;         # pre-decrement (word)
    local addr:3  = zext(ea_reg);
    local val:2    = *[ram]:2 addr;
    op_reg = op_reg * val;
}

# MULXU.W @Rn+, Rd
:MULXU.W @ea_reg+,op_reg is ea=0b1100 & op_code=0b10101 & Sz=1 & ea_reg & op_reg
{
    local addr:3  = zext(ea_reg);        # use original Rn
    local val:2    = *[ram]:2 addr;
    ea_reg = ea_reg + 2;           # post-increment (word)
    op_reg = op_reg * val;
}

# MULXU.W @aa:8, Rd
:MULXU.W @(disp8),op_reg is ea=0b0000 & ea_reg=0b101 & op_code=0b10101 & Sz=1 & disp8 & op_reg
{
    local addr:3  = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:2    = *[ram]:2 addr;
    op_reg = op_reg * val;
}

# MULXU.W @aa:16, Rd
:MULXU.W @(disp16_32),op_reg_32 is ea_32=0b0001 & ea_reg_32=0b101 & op_code_32=0b10101 & Sz_32=1 & disp16_32 & op_reg_32
{
    local addr:3  = zext(disp16_32:2);       # absolute 16-bit address
    local val:2    = *[ram]:2 addr;
    op_reg_32 = op_reg_32 * val;
}

# MULXU.W #xx:16, Rd
:MULXU.W "#"imm16_32,op_reg_32 is ea_32=0b0000 & ea_reg_32=0b100 & op_code_32=0b10101 & Sz_32=1 & imm16_32 & op_reg_32
{
    op_reg_32 = op_reg_32 * imm16_32:2;
}