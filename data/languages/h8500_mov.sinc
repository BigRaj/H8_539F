#
# h8500_mov.sinc
# Data-transfer group for H8/539F (MOV family)
# Depends on h8500_tokens.sinc
#

# We assume h8500_tokens.sinc is already @included and defines:
# - spaces: ram, register
# - registers: r0..r7, er0..er7, sp, fp, pc, ccr, dp/ep/tp/br
# - tokens: instr16, instr24, instr32
# - helper macros: push_val16/pop_val16
# - flag aliases: Z_FLAG, N_FLAG, etc.
# - attach mapping for 3-bit register fields -> r0..r7

# -------------
# Effective Address constructors
# -------------
# Each EA constructor must export an appropriate sized varnode or address
# For load forms we export a value (sized); for store forms we export an address varnode.
# We'll implement canonical forms used by MOV family in Appendix A.

#	RN COLUMN

#MOV:G.B Rn -> Rd
:MOVG.B ""^ea_reg^", "^op_reg^"" is ea=0b1010 & op_code=0b10000 & Sz=0 & ea_reg & op_reg 
{
  local val:1 = ea_reg:1;
  op_reg = (op_reg & 0xFF00) | zext(val);
}

#MOV:G.W RN -> Rd
:MOVG.W ""^ea_reg^", "^op_reg^"" is ea=0b1010 & op_code=0b10000 & Sz=1 & ea_reg & op_reg
{
	op_reg = ea_reg;
}

#XCH.W RS -> RD
:XCH.W ""^ea_reg^", "^op_reg^"" is ea=0b1010 & op_code=0b10010 & Sz=1 & ea_reg & op_reg
{
	local tmp:2 = op_reg;
	op_reg = ea_reg;
	ea_reg = tmp;
}

#SWAP.B_Rd
:SWAP.B ""^op_reg^"" is ea=0b1010 & op_code=0b00010 & Sz=0 & op_reg 
{
  local low:2  = op_reg & 0x00FF;       # isolates low byte (bits 0-7)
  local high:2 = (op_reg >> 8) & 0x00FF; # isolates high byte (bits 8-15)
  op_reg = (low << 8) | high; 		  # swaps positions
}



# @RN COLUMN

#MOV:G.B @Rn -> Rd
:MOVG.B "@"^ea_reg^", "^op_reg^"" is ea=0b1101 & op_code=0b10000 & Sz=0 & ea_reg & op_reg
{
  local addr24:3 = zext(ea_reg);
  local val:1 = *[ram]:1 addr24;
  op_reg = (op_reg & 0xFF00) | zext(val);
}

#MOV:G.W @Rn -> Rd
:MOVG.W "@"^ea_reg^", "^op_reg^"" is ea=0b1101 & op_code=0b10000 & Sz=1 & ea_reg & op_reg
{
	local addr24:3 = zext(ea_reg);
	op_reg =*[ram]:2 addr24; 
}

#MOV:G.B Rs -> @Rn
:MOVG.B ""^op_reg^", @"^ea_reg^"" is ea=0b1101 & op_code=0b10010 & Sz=0 & op_reg & ea_reg
{
	local addr24:3 = zext(ea_reg);
	local val:1 = op_reg:1;
	*[ram]:1 addr24 = val;
}

#MOV:G.W Rs-> @Rn
:MOVG.W ""^op_reg^", @"^ea_reg^"" is ea=0b1101 & op_code=0b10010 & Sz=1 & op_reg & ea_reg
{
	local addr24:3 = zext(ea_reg);
	local val:2 = op_reg;
	*[ram]:2 addr24 = val;
}

#MOV:G.B #xx:8, @Rn
:MOVG.B "#^imm8^, @"^op_reg^"" is ea=0b1101 & lo_bit=0b00000110 & Sz=0 & op_reg & imm8
{
	local addr24:3 = zext(op_reg:2);
	local val:1 = imm8;
	*[ram]:1 addr24 = val;
}

#MOV:G.W #xx:8, @Rn
:MOVG.W "#^imm8^, @"^op_reg^"" is ea=0b1101 & lo_bit=0b00000110 & Sz=1 & op_reg & imm8
{
	local addr24:3 = zext(op_reg);
  	local val16:2 = zext(imm8:1);
  	*[ram]:2 addr24 = val16;
}   

#MOV:G.W #xx:16, <EAd>
:MOVG.W "#^imm16^, @"^op_reg^"" is ea=0b1101 & lo_bit=0b00000111 & Sz=1 & op_reg & imm16
{
	local addr24:3 = zext(op_reg);
	local val:2 = imm16:2;
	*[ram]:2 addr24 = val;
}


# @(d:8,Rn) Column

#MOV:G.B @(d:8,Rn), Rd
:MOVG.B "@(" ^ disp8 ^ ", " ^ ea_reg ^ "), " ^ op_reg ^ "" is ea=0b1110 & op_code=0b10000 & Sz=0 & ea_reg & op_reg & disp8
{
	local base24:3 = zext(ea_reg:2);         # base register Rn
	local offset24:3 = sext(disp8:1);       # 8-bit signed displacement
	local addr24:3 = base24 + offset24;   # effective address
	local val:1 = *[ram]:1 addr24;        # read one byte
	op_reg = (op_reg & 0xFF00) | zext(val); # load into Rd
}

# MOV:G.W @(d:8,Rn), Rd
:MOVG.W "@("^disp8^", "^ea_reg^"), "^op_reg^"" is ea=0b1110 & op_code=0b10000 & Sz=1 & ea_reg & op_reg & disp8
{
  local base24:3   = zext(ea_reg:2);    # 16-bit register to 24-bit address
  local offset24:3 = sext(disp8:1);     # sign-extend 8-bit displacement
  local addr24:3   = base24 + offset24; # effective address
  local val:2      = *[ram]:2 addr24;   # load 2 bytes from memory
  op_reg = val;                       # copy to Rd (16-bit)
}

# MOV:G.B RS, @(d:8,Rn)
:MOVG.B ""^op_reg^", "@("^disp8^","^ea_reg^")"" is ea=0b1110 & op_code=0b10010 & Sz=0 & ea_reg & op_reg & disp8  
{
	local base24:3 = zext(ea_reg:2);
	local offset24:3 = sext(disp8:1);
	local addr24:3 = base24 + offset24;
	val:1 = op_reg:1;
	*[ram]:1 addr24 = val;
}

# MOV:G.W RS, @(d:8,Rn)
:MOVG.W ""^op_reg^", "@("^disp8^","^ea_reg^")"" is ea=0b1110 & op_code=0b10010 & Sz=1 & ea_reg & op_reg & disp8  
{
	local base24:3 = zext(ea_reg:2);
	local offset24:3 = sext(disp8:1);
	local addr24:3 = base24 + offset24;
	val:2 = op_reg:2;
	*[ram]:2 addr24 = val;
}