#
# h8500_mov.sinc
# Data-transfer group for H8/539F (MOV family)
# Depends on h8500_definitions.sinc
#

# -------------
# Effective Address constructors
# -------------
# Each EA constructor must export an appropriate sized varnode or address
# For load forms we export a value (sized); for store forms we export an address varnode.
# We'll implement canonical forms used by MOV family in Appendix A.

#	RN COLUMN

#MOV:G.B Rn -> Rd
:MOVG.B ea_reg,op_reg is ea=0b1010 & op_code=0b10000 & Sz=0 & ea_reg & op_reg 
{
  op_reg = (op_reg & 0xFF00) | zext(ea_reg:1);
}

#MOV:G.W RN -> Rd
:MOVG.W ea_reg,op_reg is ea=0b1010 & op_code=0b10000 & Sz=1 & ea_reg & op_reg
{
	op_reg = ea_reg;
}

#XCH.W RS -> RD
:XCH.W ea_reg,op_reg is ea=0b1010 & op_code=0b10010 & Sz=1 & ea_reg & op_reg
{
	local tmp:2 = op_reg;
	op_reg = ea_reg;
	ea_reg = tmp;
}

#SWAP.B_Rd
:SWAP.B op_reg is ea=0b1010 & op_code=0b00010 & Sz=0 & op_reg 
{
  local low:2  = op_reg & 0x00FF;       # isolates low byte (bits 0-7)
  local high:2 = (op_reg >> 8) & 0x00FF; # isolates high byte (bits 8-15)
  op_reg = (low << 8) | high; 		  # swaps positions
}



# @RN COLUMN

#MOV:G.B @Rn -> Rd
:MOVG.B @ea_reg,op_reg is ea=0b1101 & op_code=0b10000 & Sz=0 & ea_reg & op_reg
{
  local addr24:3 = zext(ea_reg);
  local val:1 = *[ram]:1 addr24;
  op_reg = (op_reg & 0xFF00) | zext(val);
}

#MOV:G.W @Rn -> Rd
:MOVG.W @ea_reg, op_reg is ea=0b1101 & op_code=0b10000 & Sz=1 & ea_reg & op_reg
{
	local addr24:3 = zext(ea_reg);
	op_reg =*[ram]:2 addr24; 
}

#MOV:G.B Rs -> @Rn
:MOVG.B ""^op_reg^", @"^ea_reg^"" is ea=0b1101 & op_code=0b10010 & Sz=0 & op_reg & ea_reg
{
	local addr24:3 = zext(ea_reg);
	local val:1 = op_reg:1;
	*[ram]:1 addr24 = val;
}

#MOV:G.W Rs-> @Rn
:MOVG.W ""^op_reg^", @"^ea_reg^"" is ea=0b1101 & op_code=0b10010 & Sz=1 & op_reg & ea_reg
{
	local addr24:3 = zext(ea_reg);
	local val:2 = op_reg;
	*[ram]:2 addr24 = val;
}

#MOV:G.B #xx:8, @Rn
:MOVG.B "#"^imm8^"",@op_reg is ea=0b1101 & lo_bit=0b00000110 & Sz=0 & op_reg & imm8
{
	local addr24:3 = zext(op_reg:2);
	local val:1 = imm8;
	*[ram]:1 addr24 = val;
}

#MOV:G.W #xx:8, @Rn
:MOVG.W "#"^imm8^"",@op_reg is ea=0b1101 & lo_bit=0b00000110 & Sz=1 & op_reg & imm8
{
	local addr24:3 = zext(op_reg);
  	local val16:2 = zext(imm8:1);
  	*[ram]:2 addr24 = val16;
}   

#MOV:G.W #xx:16, <EAd>
:MOVG.W "#^imm16^, @"^op_reg^"" is ea=0b1101 & lo_bit=0b00000111 & Sz=1 & op_reg & imm16
{
	local addr24:3 = zext(op_reg);
	local val:2 = imm16:2;
	*[ram]:2 addr24 = val;
}


# @(d:8,Rn) Column

#MOV:G.B @(d:8,Rn), Rd
:MOVG.B "@(" ^ disp8 ^ ", " ^ ea_reg ^ "), " ^ op_reg ^ "" is ea=0b1110 & op_code=0b10000 & Sz=0 & ea_reg & op_reg & disp8
{
	local base24:3 = zext(ea_reg:2);         # base register Rn
	local offset24:3 = sext(disp8:1);       # 8-bit signed displacement
	local addr24:3 = base24 + offset24;   # effective address
	local val:1 = *[ram]:1 addr24;        # read one byte
	op_reg = (op_reg & 0xFF00) | zext(val); # load into Rd
}

# MOV:G.W @(d:8,Rn), Rd
:MOVG.W "@("^disp8^", "^ea_reg^"), "^op_reg^"" is ea=0b1110 & op_code=0b10000 & Sz=1 & ea_reg & op_reg & disp8
{
  local base24:3   = zext(ea_reg:2);    # 16-bit register to 24-bit address
  local offset24:3 = sext(disp8:1);     # sign-extend 8-bit displacement
  local addr24:3   = base24 + offset24; # effective address
  local val:2      = *[ram]:2 addr24;   # load 2 bytes from memory
  op_reg = val;                       # copy to Rd (16-bit)
}

# MOV:G.B RS, @(d:8,Rn)
:MOVG.B ""^op_reg^", @("^disp8^","^ea_reg^")" is ea=0b1110 & op_code=0b10010 & Sz=0 & ea_reg & op_reg & disp8  
{
	local base24:3 = zext(ea_reg:2);
	local offset24:3 = sext(disp8:1);
	local addr24:3 = base24 + offset24;
	val:1 = op_reg:1;
	*[ram]:1 addr24 = val;
}

# MOV:G.W RS, @(d:8,Rn)
:MOVG.W ""^op_reg^", @("^disp8^","^ea_reg^")" is ea=0b1110 & op_code=0b10010 & Sz=1 & ea_reg & op_reg & disp8  
{
	local base24:3 = zext(ea_reg:2);
	local offset24:3 = sext(disp8:1);
	local addr24:3 = base24 + offset24;
	val:2 = op_reg:2;
	*[ram]:2 addr24 = val;
}

# MOV:G.B #xx:8, @(d:8,Rn)
:MOVG.B "#"^imm8^", @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00000110 & Sz=0 & ea_reg & disp8 & imm8
{
	local base24:3 = zext(ea_reg:2);
	local offset24:3 = sext(disp8:1);
	local addr24:3 = base24 + offset24;
	local val:1 = imm8;
	*[ram]:1 addr24 = val;
} 

# MOV:G.W #xx:8, @(d:8,Rn)
:MOVG.W "#"^imm8^", @("^disp8^","^ea_reg^")" is ea=0b1110 & lo_bit=0b00000110 & Sz=1 & ea_reg & disp8 & imm8
{
	local base24:3 = zext(ea_reg:2);
	local offset24:3 = sext(disp8:1);
	local addr24:3 = base24 + offset24;
	local val:2 = imm8;
	*[ram]:2 addr24 = val;
} 

# MOV:G.W #xx:16, @(d:8,Rn)
:MOVG.W "#"^imm16^", @("^disp8^","^ea_reg^")" is ea=0b1110 & op_code=0b00000111 & Sz=1 & ea_reg & disp8 & imm16
{
	local base24:3   = zext(ea_reg:2);   # base register Rn (16-bit)
	local offset24:3 = sext(disp8:1);    # signed 8-bit displacement
	local addr24:3   = base24 + offset24;
	local val:2    = imm16;            # 16-bit immediate value
	*[ram]:2 addr24  = val;            # store to memory
}

# MOV:G.B @(d:16,Rn), Rd
:MOVG.B "@("^disp16_32^","^ea_reg_32^"), "^op_reg_32^"" is ea_32=0b1111 & op_code_32=0b10000 & Sz_32=0 & ea_reg_32 & op_reg_32 & disp16_32
{
	local base24:3   = zext(ea_reg_32:2);
	local offset24:3 = sext(disp16_32:2);
	local addr24:3   = base24 + offset24;
	local val:1     = *[ram]:1 addr24;
	op_reg_32 = (op_reg_32 & 0xFF00) | zext(val);
}

# MOV:G.W @(d:16,Rn), Rd
:MOVG.W "@("^disp16_32^","^ea_reg_32^"), "^op_reg_32^"" is ea_32=0b1111 & op_code_32=0b10000 & Sz_32=1 & ea_reg_32 & op_reg_32 & disp16_32
{
	local base24:3   = zext(ea_reg_32:2);
	local offset24:3 = sext(disp16_32:2);
	local addr24:3   = base24 + offset24;
	local val:2     = *[ram]:2 addr24;
	op_reg_32 = (op_reg_32 & 0xFF00) | val;
}

# MOV:G.B Rs, @(d:16,Rn)
:MOVG.B ""^op_reg_32^", @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & op_code_32=0b10010 & Sz_32=0 & ea_reg_32 & op_reg_32 & disp16_32
{
	local base24:3   = zext(ea_reg_32:2);
	local offset24:3 = sext(disp16_32:2);
	local addr24:3   = base24 + offset24;
	local val:1     = op_reg_32:1;
	*[ram]:1 addr24  = val;
}

# MOV:G.W Rs, @(d:16,Rn)
:MOVG.W ""^op_reg_32^", @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & op_code_32=0b10010 & Sz_32=1 & ea_reg_32 & op_reg_32 & disp16_32
{
	local base24:3   = zext(ea_reg_32:2);
	local offset24:3 = sext(disp16_32:2);
	local addr24:3   = base24 + offset24;
	local val:2     = op_reg_32:2;
	*[ram]:2 addr24  = val;
}

# MOV:G.B #xx:8, @(d:16,Rn)
:MOVG.B "#"^imm8_32^", @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00000110 & Sz_32=0 & ea_reg_32 & disp16_32 & imm8_32
{
	local base24:3   = zext(ea_reg_32:2);
	local offset24:3 = sext(disp16_32:2);
	local addr24:3   = base24 + offset24;
	local val:1     = imm8_32:1;
	*[ram]:1 addr24  = val;
}

# MOV:G.W #xx:8, @(d:16,Rn)
:MOVG.W "#"^imm8_32^", @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00000110 & Sz_32=1 & ea_reg_32 & disp16_32 & imm8_32
{
	local base24:3   = zext(ea_reg_32:2);
	local offset24:3 = sext(disp16_32:2);
	local addr24:3   = base24 + offset24;
	local val:2     = zext(imm8_32:1);
	*[ram]:2 addr24  = val;
}

# MOV:G.W #xx:16, @(d:16,Rn)
:MOVG.W "#"^imm16_32^", @("^disp16_32^","^ea_reg_32^")" is ea_32=0b1111 & lo_bit_32=0b00000111 & Sz_32=1 & ea_reg_32 & disp16_32 & imm16_32
{
	local base24:3   = zext(ea_reg_32:2);
	local offset24:3 = sext(disp16_32:2);
	local addr24:3   = base24 + offset24;
	local val:2     = imm16_32:2;
	*[ram]:2 addr24  = val;
}

# @-Rn COLUMN
#MOV:G.B @-Rn, Rd
:MOVG.B "@-"^ea_reg^", "^op_reg^"" is ea=0b1011 & op_code=0b10000 & Sz=0 & ea_reg & op_reg
{
	local temp_ea:2 = ea_reg - 1;   # decrement Rn by 1 (byte)
	local addr24:3 = zext(temp_ea);
	local val:1 = *[ram]:1 addr24;
	op_reg = (op_reg & 0xFF00) | zext(val);
}

#MOV:G.W @-Rn, Rd
:MOVG.W "@-"^ea_reg^", "^op_reg^"" is ea=0b1011 & op_code=0b10000 & Sz=1 & ea_reg & op_reg
{
	local temp_ea:2 = ea_reg - 2;   # decrement Rn by 2 (word)
	local addr24:3 = zext(temp_ea);
	local val:2 = *[ram]:2 addr24;
	op_reg = val;
}

#MOV:G.B Rs, @-Rn
:MOVG.B ""^op_reg^", @-"^ea_reg^"" is ea=0b1011 & op_code=0b10010 & Sz=0 & op_reg & ea_reg
{
	local temp_ea:2 = ea_reg - 1;   # decrement Rn by 1 (byte)
	local addr24:3 = zext(temp_ea);
	local val:1 = op_reg:1;
	*[ram]:1 addr24 = val;
}

#MOV:G.W Rs, @-Rn
:MOVG.W ""^op_reg^", @-"^ea_reg^"" is ea=0b1011 & op_code=0b10010 & Sz=1 & op_reg & ea_reg
{
	local temp_ea:2 = ea_reg - 2;   # decrement Rn by 2 (word)
	local addr24:3 = zext(temp_ea);
	local val:2 = op_reg;
	*[ram]:2 addr24 = val;
}

#MOV:G.B #xx:8, @-Rn
:MOVG.B "#^imm8^, @-"^op_reg^"" is ea=0b1011 & lo_bit=0b00000110 & Sz=0 & op_reg & imm8
{
	local temp_op:2 = op_reg - 1;   # decrement Rn by 1 (byte)
	local addr24:3 = zext(temp_op);
	local val:1 = imm8;
	*[ram]:1 addr24 = val;
}

#MOV:G.W #xx:8, @-Rn
:MOVG.W "#^imm8^, @-"^op_reg^"" is ea=0b1011 & lo_bit=0b00000110 & Sz=1 & op_reg & imm8
{
	local temp_op:2 = op_reg - 2;   # decrement Rn by 2 (word)
	local addr24:3 = zext(temp_op);
	local val16:2 = zext(imm8:1);
	*[ram]:2 addr24 = val16;
}

#MOV:G.W #xx:16, @-Rn
:MOVG.W "#^imm16^, @-"^op_reg^"" is ea=0b1011 & lo_bit=0b00000111 & Sz=1 & op_reg & imm16
{
	local temp_op:2 = op_reg - 2;   # decrement Rn by 2 (word)
	local addr24:3 = zext(temp_op);
	local val:2 = imm16:2;
	*[ram]:2 addr24 = val;
}

# STM.W <register list>, @-SP
:STM.W "^imm8_32^, @-SP" is ea_32=0b1011 & op_code_32=0b00010010 & Sz_32=1 & ea_reg_32 & imm8_32
{
    local regmask:1 = imm8_32;    # bits R0..R7
    local bit:1 = 0;
    local temp_sp:2 = r7;         # working copy of SP
    local addr24:3;
    local val:2;

    <loop>
    if (bit == 8) goto <done>;
    # if current bit not set, advance
    if (((regmask >> bit) & 1) == 0) goto <nextbit>;

    # selected bit is set -> choose register value
    if (bit == 0) goto <case0>;
    if (bit == 1) goto <case1>;
    if (bit == 2) goto <case2>;
    if (bit == 3) goto <case3>;
    if (bit == 4) goto <case4>;
    if (bit == 5) goto <case5>;
    if (bit == 6) goto <case6>;
    goto <case7>;   # bit==7

    <case0>
    val = r0;
    goto <store>;

    <case1>
    val = r1;
    goto <store>;

    <case2>
    val = r2;
    goto <store>;

    <case3>
    val = r3;
    goto <store>;

    <case4>
    val = r4;
    goto <store>;

    <case5>
    val = r5;
    goto <store>;

    <case6>
    val = r6;
    goto <store>;

    <case7>
    val = r7;
    goto <store>;

    <store>
    temp_sp = temp_sp - 2;         # pre-decrement
    addr24 = zext(temp_sp);
    *[ram]:2 addr24 = val;
    # fall through to increment bit
    <nextbit>
    bit = bit + 1;
    goto <loop>;

    <done>
    r7 = temp_sp;                  # write back SP
}

# @Rn+ COLUMN
# MOV:G.B @Rn+, Rd
:MOVG.B "@"^ea_reg^"+, "^op_reg^"" is ea=0b1100 & op_code=0b10000 & Sz=0 & ea_reg & op_reg
{
    local addr24:3   = zext(ea_reg);                     # use original Rn
    local val:1      = *[ram]:1 addr24;
    op_reg = (op_reg & 0xFF00) | zext(val);

    local new_ea:2   = ea_reg + 1;                       # post-increment
    ea_reg = new_ea;                                    # write back to Rn
}

# MOV:G.W @Rn+, Rd
:MOVG.W "@"^ea_reg^"+, "^op_reg^"" is ea=0b1100 & op_code=0b10000 & Sz=1 & ea_reg & op_reg
{
    local addr24:3   = zext(ea_reg);                     # original Rn
    local val:2      = *[ram]:2 addr24;
    op_reg = val;

    local new_ea:2   = ea_reg + 2;                       # post-increment by 2
    ea_reg = new_ea;
}

# MOV:G.B Rs, @Rn+
:MOVG.B ""^op_reg^", @"^ea_reg^"+" is ea=0b1100 & op_code=0b10010 & Sz=0 & op_reg & ea_reg
{
	local addr24:3   = zext(ea_reg);                     # original Rn
	local val:1      = op_reg:1;
	*[ram]:1 addr24 = val;
	local new_ea:2   = ea_reg + 1;                       # post-increment
	ea_reg = new_ea;
}

# MOV:G.W Rs, @Rn+
:MOVG.W ""^op_reg^", @"^ea_reg^"+" is ea=0b1100 & op_code=0b10010 & Sz=1 & op_reg & ea_reg
{
	local addr24:3   = zext(ea_reg);                     # original Rn
	local val:2      = op_reg;
	*[ram]:2 addr24 = val;
	local new_ea:2   = ea_reg + 2;                       # post-increment
	ea_reg = new_ea;
}

#TODO: Verify these 4 instructions

# MOV:G.B #xx:8, @Rn+
:MOVG.B "#^imm8^, @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00000110 & Sz=0 & ea_reg & imm8
{
	local addr24:3   = zext(ea_reg);                     # original Rn
	local val:1      = imm8;
	*[ram]:1 addr24 = val;
	local new_ea:2   = ea_reg + 1;                       # post-increment
	ea_reg = new_ea;
}

# MOV:G.W #xx:8, @Rn+
:MOVG.W ""^imm8^", @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00000110 & Sz=1 & ea_reg & imm8
{
	local addr24:3   = zext(ea_reg);                     # original Rn
	local val16:2    = zext(imm8:1);
	*[ram]:2 addr24 = val16;
	local new_ea:2   = ea_reg + 2;                       # post-increment
	ea_reg = new_ea;
}

# MOV:G.W #xx:16, @Rn+
:MOVG.W "#"^imm16^", @"^ea_reg^"+" is ea=0b1100 & lo_bit=0b00000111 & Sz=1 & ea_reg & imm16
{
	local addr24:3   = zext(ea_reg);                     # original Rn
	local val:2      = imm16:2;
	*[ram]:2 addr24 = val;
	local new_ea:2   = ea_reg + 2;                       # post-increment
	ea_reg = new_ea;
}

# LDM.W @SP+, <register list>
:LDM.W "@SP+, "^imm8_32^"" is ea_32=0b1100 & op_code_32=0b00010000 & Sz_32=1 & ea_reg_32 & imm8_32
{
	local regmask:1 = imm8_32;    # bits R0..R7
	local bit:1 = 0;
	local temp_sp:2 = r7;         # working copy of SP
	local addr24:3;
	local val:2;

	<loop>
	if (bit == 8) goto <done>;
	# if current bit not set, advance
	if (((regmask >> bit) & 1) == 0) goto <nextbit>;

	# selected bit is set -> choose register value
	if (bit == 0) goto <case0>;
	if (bit == 1) goto <case1>;
	if (bit == 2) goto <case2>;
	if (bit == 3) goto <case3>;
	if (bit == 4) goto <case4>;
	if (bit == 5) goto <case5>;
	if (bit == 6) goto <case6>;
	goto <case7>;   # bit==7

	<case0>
	addr24 = zext(temp_sp);
	val = *[ram]:2 addr24;
	r0 = val;
	goto <advance>;

	<case1>
	addr24 = zext(temp_sp);
	val = *[ram]:2 addr24;
	r1 = val;
	goto <advance>;

	<case2>
	addr24 = zext(temp_sp);
	val = *[ram]:2 addr24;
	r2 = val;
	goto <advance>;

	<case3>
	addr24 = zext(temp_sp);
	val = *[ram]:2 addr24;
	r3 = val;
	goto <advance>;

	<case4>
	addr24 = zext(temp_sp);
	val = *[ram]:2 addr24;
	r4 = val;
	goto <advance>;

	<case5>
	addr24 = zext(temp_sp);
	val = *[ram]:2 addr24;
	r5 = val;
	goto <advance>;

	<case6>
	addr24 = zext(temp_sp);
	val = *[ram]:2 addr24;
	r6 = val;
	goto <advance>;
	<case7>
	addr24 = zext(temp_sp);
	val = *[ram]:2 addr24;
	r7 = val;
	goto <advance>;
	<advance>
	temp_sp = temp_sp + 2;         # post-increment
	# fall through to increment bit
	<nextbit>
	bit = bit + 1;
	goto <loop>;
	<done>
	r7 = temp_sp;                  # write back SP
}

# @aa:8 column
# MOV:G.B @aa:8, Rd
:MOVG.B "@("^disp8^"), "^op_reg^"" is ea=0b0000 & op_code=0b10000 & Sz=0 & ea_reg=0b101 & disp8 & op_reg
{
    local addr24:3 = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val8:1   = *[ram]:1 addr24;
    op_reg = (op_reg & 0xFF00) | zext(val8);
}

# MOV:G.W @aa:8, Rd
:MOVG.W "@("^disp8^"), "^op_reg^"" is ea=0b0000 & op_code=0b10000 & Sz=1 & ea_reg=0b101 & disp8 & op_reg
{
    local addr24:3 = 0xFF00 | zext(disp8:1);
    local val16:2  = *[ram]:2 addr24;
    op_reg = val16;
}

# MOV:G.B Rs, @aa:8
:MOVG.B ""^op_reg^", @("^disp8^")" 
  is ea=0b0000 & op_code=0b10010 & Sz=0 & ea_reg=0b101 & disp8 & op_reg
{
    local addr24:3 = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val8:1   = op_reg:1;
    *[ram]:1 addr24 = val8;
}

# MOV:G.W Rs, @aa:8
:MOVG.W ""^op_reg^", @("^disp8^")" 
  is ea=0b0000 & op_code=0b10010 & Sz=1 & ea_reg=0b101 & disp8 & op_reg
{
    local addr24:3 = 0xFF00 | zext(disp8:1);
    local val16:2  = op_reg;
    *[ram]:2 addr24 = val16;
}

# MOV:G.B #xx:8, @aa:8
:MOVG.B "#"^imm8^", @("^disp8^")" 
  is ea=0b0000 & lo_bit=0b00000110 & Sz=0 & ea_reg=0b101 & disp8 & imm8
{
    local addr24:3 = 0xFF00 | zext(disp8:1);   # absolute 8-bit address
    local val:1    = imm8;
    *[ram]:1 addr24 = val;
}

# MOV:G.W #xx:8, @aa:8
:MOVG.W "#"^imm8^", @("^disp8^")" 
  is ea=0b0000 & lo_bit=0b00000110 & Sz=1 & ea_reg=0b101 & disp8 & imm8
{
    local addr24:3 = 0xFF00 | zext(disp8:1);
    local val:2    = zext(imm8:1);
    *[ram]:2 addr24 = val;
}

# MOV:G.W #xx:16, @aa:8
:MOVG.W "#"^imm16^", @("^disp8^")" is ea=0b0000 & lo_bit=0b00000111 & Sz=1 & ea_reg=0b101 & disp8 & imm16
{
	local addr24:3 = 0xFF00 | zext(disp8:1);
	local val:2    = imm16:2;
	*[ram]:2 addr24 = val;
}

# @aa:16 column
# MOV:G.B @aa:16, Rd
:MOVG.B "@("^disp16_32^"), "^op_reg_32^"" is ea_32=0b0001 & op_code_32=0b10000 & Sz_32=0 & ea_reg_32=0b101 & disp16_32 & op_reg_32
{
    local addr24:3 = zext(disp16_32:2);       # absolute 16-bit address
    local val:1   = *[ram]:1 addr24;
    op_reg_32 = (op_reg_32 & 0xFF00) | zext(val);
}

# MOV:G.W @aa:16, Rd
:MOVG.W "@("^disp16_32^"), "^op_reg_32^"" is ea_32=0b0001 & op_code_32=0b10000 & Sz_32=1 & ea_reg_32=0b101 & disp16_32 & op_reg_32
{
    local addr24:3 = zext(disp16_32:2);
    local val:2  = *[ram]:2 addr24;
    op_reg_32 = val;
}

# MOV:G.B Rs, @aa:16
:MOVG.B ""^op_reg_32^", @("^disp16_32^")" is ea_32=0b0001 & op_code_32=0b10010 & Sz_32=0 & ea_reg_32=0b101 & disp16_32 & op_reg_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val8:1   = op_reg_32:1;
    *[ram]:1 addr24 = val8;
}

# MOV:G.W Rs, @aa:16
:MOVG.W ""^op_reg_32^", @("^disp16_32^")" is ea_32=0b0001 & op_code_32=0b10010 & Sz_32=1 & ea_reg_32=0b101 & disp16_32 & op_reg_32
{
    local addr24:3 = zext(disp16_32:2);
    local val16:2  = op_reg_32;
    *[ram]:2 addr24 = val16;
}

# MOV:G.B #xx:8, @aa:16
:MOVG.B "#"^imm8_32^", @("^disp16_32^")" 
  is ea_32=0b0001 & lo_bit_32=0b00000110 & Sz_32=0 & ea_reg_32=0b101 & disp16_32 & imm8_32
{
    local addr24:3 = zext(disp16_32:2);   # absolute 16-bit address
    local val:1    = imm8_32:1;
    *[ram]:1 addr24 = val;
}

# MOV:G.W #xx:8, @aa:16
:MOVG.W "#"^imm8_32^", @("^disp16_32^")" 
  is ea_32=0b0001 & lo_bit_32=0b00000110 & Sz_32=1 & ea_reg_32=0b101 & disp16_32 & imm8_32
{
    local addr24:3 = zext(disp16_32:2);
    local val:2    = zext(imm8_32:1);
    *[ram]:2 addr24 = val;
}

# MOV:G.W #xx:16, @aa:16
:MOVG.W "#"^imm16_32^", @("^disp16_32^")" 
  is ea_32=0b0001 & lo_bit_32=0b00000111 & Sz_32=1 & ea_reg_32=0b101 & disp16_32 & imm16_32
{
    local addr24:3 = zext(disp16_32:2);
    local val:2    = imm16_32:2;
    *[ram]:2 addr24 = val;
}

# #xx:8 column
# MOV:G.B #xx:8, Rd
:MOVG.B "#"^imm8^", "^op_reg^"" is ea=0b0000 & op_code=0b10000 & Sz=0 & ea_reg=0b100 & imm8 & op_reg
{
    op_reg = (op_reg & 0xFF00) | zext(imm8:1);
}

# #xx:16 column
# MOV:G.W #xx:16, Rd
:MOVG.W "#"^imm16_32^", "^op_reg_32^"" 
  is ea_32=0b0000 & ea_reg_32=0b110 & op_code_32=0b10000 & Sz_32=1 & imm16_32 & op_reg_32
{
    op_reg_32 = imm16_32:2;
}